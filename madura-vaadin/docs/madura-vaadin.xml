<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xml>
<?xml-stylesheet type="text/xsl" href="MaduraHTML.xsl" ?>

<doc xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="http://www.madurasoftware.com/maduradocs.xsd">
	<title>
		<MainTitle>Madura Vaadin Support</MainTitle>
		<SubTitle>User Guide</SubTitle>
		<Author>Roger Parkinson</Author>
		<Revision>$Revision: 1$</Revision>
		<image>logo.jpg</image>
		<references>
			<reference t="Spring Framework" url="http://www.springframework.org" />
			<reference t="Vaadin" url="https://vaadin.com/home"/>
			<reference t="JPAContainer" url="https://vaadin.com/directory#!addon/vaadin-jpacontainer"/>
			<reference t="madura-login" url="https://github.com/RogerParkinson/madura-vaadin-support/tree/master/madura-login"/>
			<reference t="MaduraObjects" url="https://github.com/RogerParkinson/madura-objects-parent"/>
			<reference t="MaduraRules" url="https://github.com/RogerParkinson/madura-objects-parent/tree/master/madura-rules"/>
			<reference t="Madura Rules Demo" url="https://github.com/RogerParkinson/madura-vaadin-support/tree/master/madura-rules-demo"/>
			<reference t="vaadin-touchkit" url="https://vaadin.com/add-ons/touchkit"/>
			<reference t="vaadin-addon" url="https://vaadin.com/directory#!addon/madura-vaadinsupport"/>
			<reference t="PhoneGap" url="https://vaadin.com/blog/-/blogs/packaging-vaadin-apps-for-home-screens-and-app-stores-with-phonegap"/>
			<reference t="Apache Licence 2.0" url="http://www.apache.org/licenses/LICENSE-2.0"/>
			<reference t="Madura Rules Online" url="http://rulesdemo-madura.rhcloud.com/"/>
			<reference t="Madura Mobile Online" url="http://mobiledemo-madura.rhcloud.com/"/>
		</references>
	</title>
	<body>
		<process-log/>
		<process-references/>
		<h1 t="Purpose">
		<p><courier>madura-vaadin</courier> ties together all the back-end Madura projects (Madura Objects<referenceLink t="MaduraObjects"/> and Madura Rules<referenceLink t="MaduraRules"/> etc), and delivers 
		them with a Vaadin UI<referenceLink t="Vaadin"/>. So it is worth taking a brief moment to review what those back-ends do:</p>
		<list>
		<le>Madura Objects builds your domain objects as annotated POJOs from an XSD file (using JAXB). The resulting objects behave just like POJOs except, when configured with the Madura Objects validation
		engine, they self validate as well as maintaining field metadata such as choice lists, permissions, labels etc.</le>
		<le>Madura Rules plugs into the Madura Objects validation engine to support a rules/constraints based environment that does cross-field validation as well as deriving new values (eg total of the invoice 
		lines on this invoice). It does 'truth maintenance' which means when the data changes rules might be 'unfired', keeping the derived data always 'true'.  The rules can also operate on metadata which 
		means they can change the	list of valid choices on a choice field, make a field visible or read-only etc.</le>
		</list>
		<p>This project wraps those tools to make them easy to use in a Vaadin application. The result delivers highly dynamic applications with very little application code. For example:</p>
		<list>
		<le>You can pass a POJO to a generic form which builds display fields for all the POJO fields. Each field is automatically validated according to specifications in the XSD (eg field length, numeric range checks) and
		error messages delivered where necessary. Required fields (again, as specfied in the XSD) are noted and the submit button is disabled until they are filled in, it is also disabled if there is an
		error. The generic form can accept a list of fields so you can specify which ones you want, you don't have to have them all.</le>
		<le>All field captions are fetched from the relevant XSD label and translated to the current locale.</le>
		<le>All validations on all fields are handled automatically. That means range checks, regex checks etc, but it also
		means rules based validation if you have configured it. The application code is unaware any validation is active.</le>
		<le>Error handling and delivery of any messages is synched with Vaadin's error message delivery and messages
		are locale translated.</le>
		<le>Permissions are enforced. If this user only has read-only permission on a field it will be rendered
		but disabled. If they do not have read permission it will not be rendered. If no permissions are specified on
		the field it will be rendered normally, so you only add permissions to fields you care about.</le>
		<le>Fields marked Secret in the XSD are rendered as Password style fields.</le>
		<le>Default values, if specified in the XSD, will be loaded in the obvious way.</le>
		<le>Required fields are indicated as such using Vaadin defaults.</le>
		<le>The submit buttons disable themselves until all the required fields are all filled in. They also disable
		if there are any errors in the fields they are watching. Menu items are treated much the same as buttons, so a submit menu item will be disabled until the form is complete.</le>
		<le>Any appropriate Vaadin controls can be used, not just the standard ones. All the usual theme features available in ordinary Vaadin applications are still in place. The main change is the
		use of a specialised FieldFactory which can be used on any form or field group, though this is optional anyway.</le>
		</list>
		<p>In addition, if you have configured a rules plugin, such as Madura Rules, into your validation engine:</p>
		<list>
		<le>The validation can include cross field validation.</le>
		<le>Choice lists dynamically change as the available choices change.</le>
		<le>Fields may change to/from read-only or invisible or required as rules fire.</le>
		<le>One or more buttons may be tied to boolean fields that are, in turn, controlled by rules. These buttons
		become enabled or disabled depending on the current value of the boolean.</le>
		<le>Labels and read-only fields may contain data derived from rules. This automatically updates as the rules change the data.</le>
		</list>
		<p>Still with us? Good. In addition to all that we added some extra things that come in handy:</p>
		<list>
		<le>Support for Mobile applications using Touchkit<referenceLink t="vaadin-touchkit"/> and PhoneGap<referenceLink t="PhoneGap"/>.</le>
		<le>An extension of the Vaadin JPAContainer<referenceLink t="JPAContainer"/> which supports <courier>@Transactional</courier> better. It also supports nice popup edit forms for each row. The edit forms use Madura Objects.</le>
		<le>A login filter that pops a login dialog if this user is not yet logged in. We use this for demos rather than production, but it could be customised for production.</le>
		</list>
		<p>The details of how to use all this are best explained by examples.</p>
		<list>
		<le>madura-vaadin-demo: This is a basic demo of Madura working with Vaadin. Specifically Madura Objects without Madura Rules.</le>
		<le>madura-rules-demo: This is the full demo that shows Madura Objects and Madura Rules working with Vaadin. See <referenceLink t="Madura Rules Online"/> for the on-line demo.</le>
		<le>madura-address-book: Demonstrates the extended JPA container and a pop-up row editor which has Madura Objects backing the fields.</le>
		<le>madura-mobile-demo: Demonstrates an application that presents both a desktop and mobile UI, both backed by Madura Objects and Madura Rules. See <referenceLink t="Madura Mobile Online"/> for the on-line demo.</le>
		</list>
 		<p>These demos form the basis of this documentation and we will refer to them extensively. 
<!--  		The core code is packaged as a vaadin-addon<referenceLink t="vaadin-addon"/> available from the Vaadin site. -->
 		</p>
		</h1>
		<h1 t="Common Techniques">
		<p>All the demos use Vaadin 7, Spring<referenceLink t="Spring Framework"/>, Madura and Maven. We assume you are reasonably familiar with all of these.</p>
		<p>To build use: <courier>mvn install</courier></p>
		<p>To run with Jetty use: <courier>mvn jetty:run</courier> and open <courier>http://localhost:8080/</courier>. You can also run them with Eclipse WTP. We tested with Tomcat 7.</p>
		<p>To login the user/password is always admin/admin, you can also use user/user</p>
		<p>The login process is managed by the <courier>madura-login</courier><sectionLink t="madura-login"/> project. This provides a simple login facility suitable for demos simply by making it
		a maven dependency and a little configuration.</p>
        <p>As is usual in Madura Objects we have some files in the resources directory. These are mostly things like <courier>logback.xml</courier> as well as files covered in Madura Objects or Madura Rules documentation.
        But because they are so important we will mention the XSD files which define the objects. There is an entry in the maven <courier>pom.xml</courier> file that invokes <courier>madura-objects-maven-plugin</courier>
        which is just a jacket for JAXB that saves you having to configure JAXB for Madura. That generates annotated Java files from the XSD and puts them into the <courier>generated-sources/xjc</courier>
        directory. You never edit those Java file, you change the XSD and regenerate.</p>
        <p>Vaadin also has a maven plugin: <courier>vaadin-maven-plugin</courier> which generates the widgetsets.</p>
		<p>Each demo makes use of Spring Configuration in preference to Spring XML and we also make use of the Vaadin-Spring Addon. However it is simpler to allow one
		XML component because of the way the defaults work. So each project has an <courier>applicationContext.xml</courier> file in the <courier>WEB-INF</courier> directory. It looks like this 
		(excluding the headers etc for brevity):</p>
        <code><![CDATA[
...
<context:component-scan base-package="nz.co.senanque.vaadindemo, nz.co.senanque.login" />
<bean id="permissionManager" class="nz.co.senanque.vaadin.permissionmanager.PermissionManagerImpl" scope="vaadin-ui"/>
<bean id="messageSource" class="nz.co.senanque.resourceloader.ResourceBundleMessageSourceExt">
	<property name="basenames">
		<list>
			<value>ApplicationMessages</value>
		</list>
	</property>
</bean>
</bean>
        ]]></code>
        <p>This does three things. It tells Spring to scan the application package for component beans, and the login package as well because it has components we want too. 
        It defines the <courier>permissionManager</courier> bean which is needed to hold this user's permissions. There is more about this in <sectionLink t="madura-login"/>. 
        The context file also creates
        the message source. <courier>ApplicationMessages</courier> are the messages for the current demo. <courier>ResourceBundleMessageSourceExt</courier> is just like Spring's 
        <courier>ResourceBundleMessageSource</courier> except it can go find the properties files in various jar files by itself.</p>
        <p>But most of the Spring configuration is in the code. Each demo has a class that extends <courier>com.vaadin.ui.UI</courier> called either 
        <courier>MyUI</courier> or <courier>AddressBookUI</courier> or similar. This contains the configuration.</p>
        <code><![CDATA[
@Theme("mytheme")
@Title("Madura Vaadin Demo")
@Widgetset("com.vaadin.DefaultWidgetSet")
@SpringUI
public class MyUI extends UI {

    @Autowired private MaduraSessionManager m_maduraSessionManager;
    @Autowired private DefaultView m_defaultView;

    @WebServlet(name = "MyUIServlet", urlPatterns = "/*", asyncSupported = true)
    public static class MyUIServlet extends SpringVaadinServlet {

		private static final long serialVersionUID = 1L;
    }

    @WebListener
    public static class MyContextLoaderListener extends ContextLoaderListener {
    	// This causes the applicationContext.xml context file to be loaded
    	// per session.
    }
...
        ]]></code>
		<p>The first three annotations are normal Spring-Vaadin things that ensure this class is loaded with the right theme etc. You can also see a static class that declares a servlet
		as well as a web listener. The listener is what loads the <courier>applicationContext.xml</courier> you saw above.</p>
		<p>There are also two auto wirings, one for the current MaduraSessionManager and one for a local class which defines most of the UI. There is
		often more than one of these classes.</p>
		<p>After that there is a static class that defines the configuration. It is worth noting that the above section is created and wired <emph>per session</emph> whereas this following section
		is <emph>per application</emph> ie singletons, except for those annotated <courier>UIScope</courier> which are session beans.</p>
        <code><![CDATA[
...
@Configuration
@EnableVaadin
@ComponentScan(basePackages = {
		"nz.co.senanque.vaadin",
		"nz.co.senanque.validationengine"})
@PropertySource("classpath:config.properties")
public static class MyConfiguration {
	
	public MyConfiguration() {
	}
   	// needed for @PropertySource
   	@Bean
   	public static PropertySourcesPlaceholderConfigurer propertyConfigInDev() {
   		return new PropertySourcesPlaceholderConfigurer();
   	}
   	@Bean(name="hints")
   	@UIScope
   	public Hints getHints() {
   		return new HintsImpl();
   	}
}
...
        ]]></code>
        <p>The things to note here are that there are more packages to scan, namely the validation engine and the components of the madura-vaadin project. We also specify a properties file which injects values
        into these scanned components. You will see the <courier>config.properties</courier> file in the resources directory and it holds those values. The <courier>hints</courier> bean is defined here
        rather than scanned so that you can replace it with your own implementation. The hints bean helps the field factory decide what kind of field to create in various circumstances. The one used
        here works just fine but you might want something different.</p>
        <p>The <courier>config.properties</courier> only needs to know what package the generated Java classes are in, like this:</p>
        <code><![CDATA[
nz.co.senanque.validationengine.metadata.AnnotationsMetadataFactory.packages=nz.co.senanque.pizzaorder.instances
		]]></code>
        <p>Next up is the <courier>init</courier> method which is called when the user session is created.</p>
        <code><![CDATA[
...
    protected void init(VaadinRequest vaadinRequest) {
    	
    	MessageSourceAccessor messageSourceAccessor= new MessageSourceAccessor(m_maduraSessionManager.getMessageSource());
    	final String logout = messageSourceAccessor.getMessage("logout");
...
        ]]></code>
        <p>This is fairly ordinary Spring code that uses a <courier>MessageSourceAccessor</courier> to translate the logout string. It is interesting because it shows that
        for various headings or captions of components that are not controlled by Madura we still need to call a <courier>MessageSourceAccessor</courier> for I18n, but most of the time we don't.</p>
        <p>The <courier>DefaultView</courier> class was mentioned above. It is auto wired into the <courier>MyUI</courier> class and all of the demos have one or more classes like this, so let's take a brief look at
        one of them:</p>
        <code><![CDATA[
...
@UIScope
@SpringComponent
public class DefaultView extends VerticalLayout implements MessageSourceAware {

	@Autowired private MaduraSessionManager m_maduraSessionManager;
...
        ]]></code>
        <p>The two class annotations ensure that Spring loads this as a session component, and the <courier>MaduraSessionManager</courier> is auto wired. The <courier>MaduraSessionManager</courier> is the 
        general purpose API we use to get to Madura so we need it everywhere.</p>
		<p>Now we can look inside the first demo.</p>
		</h1>
		<h1 t="madura-vaadin-demo">
		<p>The interesting things in this project are in the <courier>nz.co.senanque.vaadindemo.DefaultView</courier>. You saw it briefly in the previous section so you know it is a session dependent bean and
		it has a <courier>MaduraSessionManager</courier> injected.</p>
		<p>It has an <courier>init</courier> method which runs once Spring has instantiated the bean and finished injecting everything. All it does is set up a layout called <courier>panel</courier>.</p>
		<p>The <courier>load()</courier> method is passed a <courier>Person</courier> object. It does the following:</p>
		<list>
		<le>clears the <courier>panel</courier> layout we created in the <courier>init()</courier>.</le>
		<le>makes sure the <courier>Person</courier> is bound to our validation session.</le>
		<le>clears the <courier>panel</courier> layout we created in the <courier>init()</courier>.</le>
		<le>Wrap the <courier>Person</courier> in a <courier>BeanItem</courier>.</le>
		<le>Create a new layout and add it to the <courier>panel</courier>.</le>
		<le>Use the Madura Session Manager to create a Madura Field Group.</le>
		<le>Create the buttons, more detail below.</le>
		<le>Create the fields using <courier>buildAndBind</courier>. Then add them to the form using a loop.</le>
		</list>
		<p>Creating the buttons is done <emph>before</emph> the rest of the fields are created. The code is in the <courier>createActions</courier> method which creates two buttons. The two 
		buttons don't do much (this is a demo, remember). But how they are created is important.</p>
        <code><![CDATA[
...
Button cancel = fieldGroup.createButton("button.cancel", new ClickListener(){
...
	}});
...
        ]]></code>
		<p>There is not much to this really. It creates a button, translates the name and adds the listener. But we might have used a variation on this:</p>
        <code><![CDATA[
...
Button cancel = fieldGroup.createButton("button.cancel", "ADMIN", new ClickListener(){
...
	}});
...
        ]]></code>
        <p>In this case we added a permission. If the user does not have this permission the button will be disabled.</p>
        <p>The second button is similar:</p>
        <code><![CDATA[
...
Button submit = fieldGroup.createSubmitButton("button.submit", new ClickListener(){
...
	}});
...
        ]]></code>
        <p>This button is a <emph>submit</emph> button. For us that means all fields in the field group that are flagged as required must have values before the button will be enabled. They also have to be valid. 
        The validation rules and the required flags are specified in the XSD file, not here, so the UI designer does not need to worry about those things. As with the previous button you could add a permission
        argument. Permissions always trump everything else so even if a user has filled in the fields correctly the submit button will not enable unless they have the permission. If you want to make one of the buttons
        the default button, ie what happens when the user presses enter, you do this:</p>
        <code><![CDATA[
submit.setClickShortcut( KeyCode.ENTER );
submit.addStyleName( ValoTheme.BUTTON_PRIMARY );
        ]]></code>
        <p>The style is optional and we've chosen the one one appropriate to Vaadin's Valo theme. If we were using a different theme we would use a different style here.</p>
        <p>After the buttons are created the next thing that happens is:</p>
        <code><![CDATA[
Map<String,Field<?>> fields = fieldGroup.buildAndBind(m_fields, beanItem);
        ]]></code>
        <p>This calls the field factory to create a field for each of the property ids in the <courier>m_fields</courier> array, binding each one to the <courier>beanitem</courier> object.
        A short loop just after that adds these fields to the layout created earlier and they end up on the form.</p>
        <p>The result is a display with several fields, complete with I18n captions, backed by the Madura Object <courier>person</courier>. The buttons etc are also bound so that Submit button will be disabled
        if the <courier>person</courier> does not have all the required fields completed. The fields are all wired with validation and the field types vary by data type, so there are three text fields,
		one drop down which is populated with choices, a date and several numeric text fields.</p>
        <p>This is not the only way to achieve this, and you will see alternative approaches in subsequent demos. They are summarised in <sectionLink t="MaduraFieldGroup and MaduraForm"/></p>
        <p>The result is in <figureLink t="Madura Vaadin Demo"/></p>
        <img width="12cm" href="images/VaadinDemo.png">Madura Vaadin Demo</img>
        <p>Notice that two of the numeric fields are formatted with commas and periods. This is done according to the formating rules in the XSD. These adapt according to locale. The different field types,
        including the boolean, are derived from the <courier>hints</courier> bean which you can customise for your own needs.</p>
		</h1>
		<h1 t="madura-rules-demo">
		<p>There is an on-line demo of this at <referenceLink t="Madura Rules Online"/>.</p>
		<p>This demo is more complicated, and it uses Madura Rules so there are some configuration differences too. We will look at those first.</p>
		<p>The <courier>applicationContext.xml</courier> has an extra package to scan, this is the package we put the generated rules in.</p>
		<p>Madura Rules uses a maven plugin to generate Java rules in much the same way Madura Objects generated Java objects from the XSD. When you use Madura Rules you always use Madura Objects as well,
		so we have the usual XSD file and an entry for it the <courier>pom.xml</courier>. We also have a RUL file in the resources directory. That defines the rules and there is plugin configured in the pom file
		called <courier>madura-rules-maven-plugin</courier>. That puts the rules Java into <courier>generated-sources/xjc</courier> package <courier>nz.co.senanque.pizzaorder.rules</courier> which is the
		package specified in <courier>applicationContext.xml</courier>.</p>
		<p>The <courier>choices.xml</courier> file is more interesting in this demo because it includes more choice list entries (some aren't actually used), a decision table and a constant. There is more Java code as well,
		but this is not because we added rules, it is because we added more demo.</p>
		<p>As usual there is a <courier>com.vaadin.ui.UI</courier> extension (called <courier>MyUI</courier>). It looks much the same, but we are scanning one more package: <courier>nz.co.senanque.rules</courier>
		to pick up the rules components. These are the out-of-the-box rules component classes as opposed to the generated rules classes scanned in the <courier>applicationContext.xml</courier> file. Other than that
		all this class does is create a <courier>TabSheet</courier> on which it places the injected UI components so we will look a those one by one.</p>
		<p>An important point to notice here is that apart from adding those directories to be scanned the code is comletely unaware of the rules.</p>
		<h2 t="CustomerView">
        <img width="12cm" href="images/RulesDemo1.png">Customer Screen</img>
		<p>This is labelled 'Customer' on the UI (unless you are using the French version). It looks a bit like the first demo but with fewer fields and more buttons.</p>
		<p>There are 5 variants of this customer UI and you can see the others on tabs labelled C2...C5. They are functionally equivalent but each uses a different coding technique to achieve the
		same result. The details of the code are covered in <referenceLink t="MaduraFieldGroup and MaduraForm"/>. For now you need to know the fields you see are bound to a <courier>Customer</courier>
		object and will display fields from that object. There are two required fields (marked with red asterisks) on the form. That means they have to be given values, and they have to
		be correct values. This becomes important in the <courier>email</courier> field which needs to be of the form <courier>xx@xxx</courier>. You should try the demo with different values
		and see how errors are displayed etc. Notice that the Submit button does not enable until both required fields have valid values. This is the same as the madura-vaadin-demo <sectionLink t="madura-vaadin-demo"/>.</p>
		<p>The demo also has a disabled BMI button. This is a different sort of button, created using:</p>
        <code><![CDATA[
Button bmi = customerForm.createFieldButton("button.bmi", "dynamic","ADMIN", new ClickListener(){
        ]]></code>
        <p>There is a boolean field called <courier>dynamic</courier> in the <courier>Customer</courier> object and this code creates a button that is disabled or enabled depending on whether <courier>dynamic</courier>
        is false or true. This would not be all that useful if nothing changed the value of <courier>dynamic</courier>, but there is a rule in the <courier>PizzaOrder.rul</courier> file:</p>
        <code><![CDATA[
rule: Customer "dynamic"
{
	if (name == "fred")
	{
		dynamic = true;
	}
}
        ]]></code>
        <p>This may be fairly obvious, but if it is not then you can find more details in the Madura Rules documentation. If we enter 'fred' into the <courier>name</courier> field the rules will fire and set
        <courier>dynamic</courier> to true, and that will cause the button to enable, unless this user doesn't have the ADMIN permission. This example should give you a feel for how the operation of the rules
        is detached from the UI code. The UI knows about a field called <courier>dynamic</courier>, it does not know about the rule. Similarly the rule knows about <courier>dynamic</courier> but it knows nothing about
        the UI. Yet a change from the rules propagates to the UI. We will see this a lot.</p>
        <p>Just after we created the <courier>MaduraForm</courier> we set the field list into it. This list is turned into fields with captions on a <courier>VerticalLayout</courier>. All it needs after that is an actual object
        and that is set in the <courier>enter</courier> method.</p>
        <p>The <courier>BMI</courier> button has a a listener attached that actually does something:</p>
        <code><![CDATA[
m_oneFieldWindowFactory.createWindow(m_customer, "bmi",ValoTheme.BUTTON_PRIMARY);
        ]]></code>
		<p>This invokes the directed questioning mode of the rules. What happens is quite complex, but this is all you need to use it. We pass the object, it has to be a Madura Object of course, ie generated from the XSD,
		the name of a property on the object and, optionally, a style for a submit button. The rules engine will look for rules that output that property and try and work out a value using them. Each time it finds
		it needs more information it will prompt for it. In this  case there is a rule:</p>
        <code><![CDATA[
formula: Customer "BMI"
{
	bmi = weight / (height * height);
}
        ]]></code>
        <p>So it asks for weight and height on two different pop-up windows. It can be more complicated than that. Some people like to give these measurements in imperial units, some in metric, and they don't know, say, 
        their height in metres. But that is okay. You can say you don't know and it will ask for feet then inches (two prompts). This feature can be used to simplify complicated input sequences that may need only a few
        relevant inputs, depending on the context. If the property is already filled in, perhaps the height was obtained earlier, then it knows not to ask for it. This example shows a fairly simple level of nesting,
        but it can go infinitely deep.</p>
        <p>The other tabs (C2...C5) do the same thing, with a slight variation in C3 which uses a menu item rather than a Submit button.</p>
		</h2>
		<h2 t="OrderView">
		<p>The order view is labelled 'Order' on the TabSet. This one does a little order entry function, like a shopping cart. We are ordering pizza but we need to say what kind of topping, size and base
		we want. And not all combinations are allowed. As we order pizzas they appear in the table on the order view.</p>
		<p>In this view we use a <courier>MaduraFieldGroup</courier> to display the status of the order in  two labels. The interesting thing about this is that instead of using input fields, which
		you have already seen, these components are labels and they are dynamic as we shall see. If we get the <courier>MaduraFieldGroup</courier> to create the fields
		it will always create input fields, possibly disabled ones, because it doesn't know any better. So this is an example of adding customisation.</p>
		<p>The table is a <courier>FormattingTable</courier> which extends Vaadin's table to handle I18n headings and formating numerics. There are two columns on this table and one of them is numeric.
		To set it up all we need to do is name the properties we want to display ("description","-amount") and add a minus sign to the amount to right justify it. And we also name the headings ("Description","Amount"). 
		Those headings will be used as is if there is no resource translation, but if there is the translation will be used.</p>
		<p>The 'Add Item' button creates a popup window which allows you to create an order item.</p>
		<h3 t="PizzaWindow">
        <img width="12cm" href="images/RulesDemo2.png">Pizza Screen</img>
		<p>The 'Add Item' button invokes the <courier>PizzaWindow</courier>. This uses a <courier>MaduraFieldGroup</courier> to present the fields on the <courier>Pizza</courier> object. The code is similar to Customer view. It is worth running the demo at this point to see what it does.
		You can see the three fields: Base, Topping, Size. Because only some combinations are valid you will find that as you pick options in, say, the Topping field, and list of options on the Size field will change, and vice versa.
		It doesn't matter what order you pick them. This is driven by the decision table in <courier>choices.xml</courier>. It does not have to be hard coded XML either, the values can be pulled from external sources such
		as a database. How to do that is in the Madura Rules documentation.</p>
		<p>The other thing you will see when picking options is that the amount field, which is read only, will get a value and a new field 'testing' will appear. This is because of rules like this:</p>
        <code><![CDATA[
rule: Pizza "p2"
{
	if (size == "Small")
	{
		readonly(testing);
		activate(testing);
		amount = 10;
	}
}
        ]]></code>
        <p>The 'testing' field varies from inactive, active (ie visible), read-only, read-write and required. A description field displays the concatenation of the base, topping and size fields.</p>
        <p>As usual there is a submit button on the display and the submit button is aware of whether the 'testing' field is required and not filled in, or not required, so it can enable and disable accordingly.</p>
        <p>Once you click the submit button the pizza is added to the order, which means it displays in the shopping cart. The labels at the top of the Order view will change. Previously they said 'Shopping cart is empty'
        and a value of zero. Once you add a pizza it will say '1 items in cart' and the sum of the pizza values. How does that happen? Where is the code?</p>
        <p>You probably guessed it is in the rules.</p>
        <code><![CDATA[
rule: Order "shoppingcartsize"
{
	if (count(pizzas) > 0)
	{
		orderStatus = format("shopping.cart.status",count(pizzas));
	}
}
rule: Order "shoppingcartsize"
{
	if (count(pizzas) == 0)
	{
		orderStatus = format("shopping.cart.status.empty",0);
	}
}
        ]]></code>
        <p>It relies on two resource strings:</p>
        <code><![CDATA[
shopping.cart.status.empty=Shopping cart is empty
shopping.cart.status={0} items in cart
        ]]></code>
		<p>'pizzas' is a field on the Order which holds a list, and there are a number of built in functions that handle lists. What about the total? Yes, another rule:</p>
        <code><![CDATA[
formula: Order "sum"
{
	amount = sum(pizzas.amount); 
}
        ]]></code>
        <p>Again, the rules do not know about the UI and the UI does not know about the rules, but the values automatically update. This demo does not provide a way to delete pizzas but if it did the total
        and the status would update appropriately because the rules know to re-fire when the data they worked with changes.</p>
		</h3>
		</h2>
		</h1>
		<h1 t="madura-address-book">
        <img width="12cm" href="images/Table.png">Address Book</img>
		<p>This demo is all about displaying and editing rows from a database in a table. It uses Madura Objects but not Madura Rules. It does use the madura-tableeditor so that needs to be specified as a
		maven dependency and the <courier>nz.co.senanque.vaadin.tableeditor</courier> package has to be scanned so that is added to the <courier>ComponentScan</courier> in the <courier>AddressBookUI</courier>
		class.</p>
		<p>We also define beans in the <courier>MyConfiguration</courier> class: a table layout for persons and for trees.</p>
		<p>The <courier>nz.co.senanque.addressbook.jpa</courier> package defines a data source and demo code to load hard coded values into an in-memory H2 database.</p>
		<p>There is actually very little code in this demo because it is driven from the data structures. Once the table is loaded and visible you can right click to see a context menu
		giving options to edit, add or delete records. When adding or editing you have a Madura-backed Vaadin form with the usual validation and dynamic submit button you have seen in the other demos. It does
		not use Madura Rules but if it did there would be no change to the code except for some extra packages to scan.</p>
		<h2 t="Table Editor">
		<p>The table editor is used in the address book demo. It is a bit more complicated to configure than the other components so this section details that.</p>
		<p>First there needs to be a database defined. The address book demo only uses one database, which is more common than multiple
		database connections. The connection is defined in the <courier>ConfigJPA</courier> class. If defines three beans: a data source, and entity manager factory and a transaction manager. Because this is a demo
		we've used an in-memory H2 database and it gets loaded with data by the <courier>LoadJPA</courier> bean. Naturally this would
		be reworked for a production system.</p>
		<p>The next class to look at is <courier>ConfigContainer</courier>. This class defines the two containers used in the demo: one for
		the people and one for the trees. Apart from their data types and bean names these beans are the same, and because they are so similar we
		need to give them names to make sure the right bean is injected into the right place. Do not be tempted to put container beans into
		your <courier>ConfigJPA</courier> file. These beans need the <courier>EntityManager</courier> established and that is actually
		done in the <courier>ConfigJPA</courier>, which means you cannot use it in that class hence the need for the <courier>ConfigContainer</courier>
		class.</p>
		<p>All of the above beans are singletons. The rest of this is tied to a session.</p>
		<p>In <courier>AddressBook.MyConfiguration</courier> the two containers are injected using their names. They each help define the
		<courier>personTableLayout</courier> and <courier>treeTableLayout</courier> beans. Those are the actual table layouts, they are Vaadin
		components and they are added to the <courier>PersonView</courier> and <courier>TreeView</courier> tabs</p>
		<p>The container effectively defines a database query on a table. In the demo case the query is for all records but it can be refined
		in various ways. See the Vaadin documentation for that.<referenceLink t="JPAContainer"/></p>
		</h2>

		</h1>
		<h1 t="MaduraFieldGroup and MaduraForm">
		<p>Most of the demos make use of <courier>MaduraFieldGroup</courier> in various ways, and the ones that do not use <courier>MaduraForm</courier>. How do you know what technique to use?</p>
		<p>Bear in mind there are two distinct phases that are always present. The first phase is the initialise phase. This is called once at application startup or, more usually, at session startup. The second phase
		is when we have an object such as a person, a customer or maybe a pizza, to bind to. This might be called multiple times as we operate on different customer or different pizzas.</p>
		<p>This section refers to a number of examples and they are all found in Madura Rules Demo<referenceLink t="Madura Rules Demo"/> under <courier>src/main/java</courier>.</p>
		<h2 t="MaduraForm">
		<p><courier>MaduraForm</courier> is based on Vaadin's <courier>Form</courier> which is deprecated, a possible reason not to use it. <courier>Form</courier>, and therefore <courier>MaduraForm</courier> is
		a <courier>Component</courier> which can be added to the display. You normally let the <courier>Form</courier> create its own fields and position them where it likes, usually in a vertical layout.</p>
		<p>The steps you perform to use <courier>MaduraForm</courier> are:</p>
		<list>
		<le>Initialise it with the constructor passing <courier>MaduraSessionManager</courier>. You can pass an optional layout in the constructor as well and this is what the created fields will be added to. The default is a vertical layout
		but you do have more options than that.</le>
		<le>Set the list of field names using <courier>setFieldList</courier>. The fields will be created when there is an object bound. If you set an invalid name it will be ignored without error.</le>
		<le>create any buttons you want using the form methods and position them where you like.</le>
		</list>
		<p>That was the initialisation phase. For the bind phase use <courier>setItemDataSource</courier>, to set a data source object. This triggers the creation of the UI fields.</p>
		<p>The example for this is <courier>nz.co.senanque.madurarulesdemo.CustomerView</courier> and you will find this class running in the CustomerView tab.</p>
		</h2>
		<h2 t="MaduraFieldGroup">
		<p>The <courier>MaduraFieldGroup</courier> is the (non-deprecated) replacement to <courier>MaduraForm</courier>, which parallels the developments at Vaadin. The essential difference in the new class is that it
		is <emph>not</emph> a component. You get to create the fields yourself and bind them. At least that seems to be Vaadin's intention, but we rather like passing a list of fields and having them created
		for us. There are three different ways to use <courier>MaduraFieldGroup</courier> and these are covered in four examples: <courier>nz.co.senanque.madurarulesdemo.CustomerView2, nz.co.senanque.madurarulesdemo.CustomerView3, nz.co.senanque.madurarulesdemo.CustomerView4, nz.co.senanque.madurarulesdemo.CustomerView5</courier>.
		When running the demo you can find these classes running under tabs C2, C3, C4 and C5.</p>
		<p>But before you feel overcome by too many choices here we can say that our preference is for C5, and that C3 is a minor variation on C2, the difference being that it uses a menu bar rather than a button, so it does not really
		count as a different approach. So what are the essential differences between these approaches and how do they work?</p>
		<p>First let's look at the common elements: each of these classes is a Vaadin component, they extend <courier>com.vaadin.ui.VerticalLayout</courier>. They are all <courier>@UIScope</courier> components which means
		they are all created per session by Spring. They each have a <courier>@PostConstruct</courier> method (named <courier>init</courier>) called by Spring, a <courier>load()</courier> method called by the aplication. They
		are all injected with a <courier>MaduraSessionManager</courier> object because they all use Madura Objects.</p>
		<p>When <courier>init()</courier> is called we do not have an object to display and update, that is passed in the <courier>load()</courier> method.</p>
		<h3 t="C2 (and C3)">
		<p>The <courier>init()</courier> method creates the field components and adds them to the layout, including the buttons and/or menu items. It does this using the injected <courier>MaduraSessionManager</courier>
		object to create a <courier>MaduraFieldGroup</courier> and this is called to create menu items and buttons, as well as to bind the fields to the field group.</p>
		<p>The <courier>load()</courier> just calls the <courier>setItemDataSource()</courier> on the field group already created.</p>
		<p>You get complete control over what kinds of fields are created and where they are put with this approach. This can be an advantage and a disadvantage. You get precisely what you want, of course, but you have
		to maintain consistency yourself. If, say, the status field is normally rendered as a <courier>ComboBox</courier> it is up to you to ensure it is a <courier>ComboBox</courier> here.</p>
		</h3>
		<h3 t="C4">
		<p>In this example the <courier>init()</courier> method does very little, it just sets up a layout for us to add fields to later. The main work is done in the <courier>load()</courier> method which calls the field group <courier>buildAndBind()</courier> method.
		The <courier>buildAndBind()</courier> method accepts a list of property ids and for each of those it creates a field driven by the customisable hints (<courier>nz.co.senanque.vaadin.Hints</courier>) bean. It
		returns a map of property ids and components which are then added to the layout in whatever way we want.</p>
		<p>The advantages of this approach is that you will get consistencey of field types generated for properties automatically, you do not have to remember that the status field ought to be a <courier>ComboBox</courier> but
		you get complete control over where the fields are placed on the layout. You can even coerce them into different enabled/disabled states if you want, though we prefer to use Madura Objects to do that for us because, like
		the field type, it gives us automatic consistency.</p>
		</h3>
		<h3 t="C5">
		<p>This is very like the C4 example except that it uses another variant of the <courier>buildAndBind()</courier> method. It passes a layout in the first argument and dispenses with the
		loop C4 used to add the fields to the layout. This <courier>buildAndBind()</courier> variant does the loop internally. It gives you less control over the placement of the fields but
		it is less to code.</p> 
		</h3>
		</h2>
		</h1>
        <h1 t="Mobile Applications">
        <p>There is an on-line demo of the mobile application described here at <referenceLink t="Madura Mobile Online"/>.</p>
        <h2 t="Touchkit">
        <p>Touchkit is an addon product produced by Vaadin to enable 'touch' devices like phones and tablets, so this
        is what you need for a mobile application. There is a lot to Touchkit that we will not cover here (just as there
        is a lot to Vaadin that we don't cover). But we will do the basics and show it working with Madura.</p>
        <p>Touchkit is a dual licence product. If your project qualifies for AGPL then you use the free agpl version. If not
        you need to buy a licence from Vaadin. Our demos are AGPL so they use the agpl version.</p>
        <p>At the time of writing the version of Touchkit we need was not in the maven central repository so there are some
        repository references in the pom file for the demos.</p>
        <p>But the demo project does not refer to Touchkit directly. There is a <courier>madura-vaadin-touchkit</courier>library that
        adds some Touchkit specifics to help Madura, and that has the dependency</p>
        <code><![CDATA[
<dependency>
	<groupId>com.vaadin.addon</groupId>
	<artifactId>vaadin-touchkit-agpl</artifactId>
	<version>4.0.0</version>
	<type>jar</type>
</dependency>
        ]]></code>
        <p>But what you will find in the <courier>madura-mobile-demo</courier> is this:</p>
        <code><![CDATA[
<dependency>
	<groupId>nz.co.senanque</groupId>
	<artifactId>madura-vaadin-touchkit</artifactId>
</dependency>
        ]]></code>
        </h2>
		<h2 t="The Demo">
		<p>The <courier>madura-mobile-demo</courier> project is the one we are looking at. This combines <emph>two</emph> UIs: a desktop UI
		and a mobile UI. The two UIs do much the same thing, they certainly have the same underlying objects and rules (using Madura Objects)and Madura Rules, of course).
		Part of the point is to show that while you might have to deliver a different UI for a different technology you do not
		have to re-engineer the object and rules to doit.</p>
		<p>The <courier>MaduraMobileDemoDesktopUI</courier> is essentially no different from the UI class in the other demos. It is
		an extention of the <courier>com.vaadin.ui.UI</courier> class and has similar annotations. The one thing you might find puzzling there is
		that the various static classes that define the web servlet, web listener and Spring configuration are missing.
		They are in the mobile UI class. There have to be only one instance of these
		in the application and in this case the one isntance is in the other class. But
		it does not matter where they are as long as they are present somewhere.</p>
		<p>The more interesting class at this point is the <courier>MaduraMobileDemoTouchKitUI</courier> class.</p>
		<p>The first thing to notice abut this class is that the static classes are present here, but the
		servlet class extends <courier>SpringAwareTouchkitServlet</courier>. This implements some things needed for
		Touchkit to work correctly with Spring. The class is adapted from Matti Tahvonen's version. Matti Tahvonen
		works for Vaadin.</p>
		<p>The next thing to notice is the annotations on the UI are a little different.</p>
        <code><![CDATA[
@Widgetset("com.vaadin.addon.touchkit.gwt.TouchKitWidgetSet")
@Theme("madura-touchkit-theme")
@SpringUI(path="mobile")
public class MaduraMobileDemoTouchKitUI extends UI {
...
        ]]></code>
        <p>The widgetset is the default one for Touchkit.</p>
        <p>The theme is one derived from the Touchkit theme, which is different from the desktop theme. Touchkit requires its own theme
        and we've added a small addition to it to make numeric fields justify right. The theme comes from the <courier>madura-vaadin-touchkit</courier>
        dependency. If you don't care about the right justify you can use 'touchkit' there instead.</p>
        <p>To get to the mobile UI there needs to be a <courier>/mobile</courier> added to the URL. This is
        actually done for us by the login sequence is you are using <courier>madura-login</courier>, but if your application
        uses something else instead you will need to have it redirect to the right UI.</p>
        <p>The rest of the UI, including the classes it invokes are much the same as the desktop UI except that there
        are some Touchkit specific controls used such as <courier>NavigationManager</courier>. You can use the same
        techniques for creating and binding objects to your UI. When it creates UI fields for you a different field factory
        is invoked to supply Touchkit fields rather than desktop ones.</p>
        <p>That brings us to the last thing to notice about the UI class namely the definition of the <courier>hints</courier>
        bean. In the other demos this just returned <courier>HintsImpl</courier> but here we need to make a decision about what
        hints we want because they are different. As with the other demos this gives you the opportunity to customise the hints
        by supplying your own hints classes.</p>
        <p>The desktop screen looks much like the rules demo you saw earlier. The mobile screens look like this:</p>
        <img width="12cm" href="images/MobileDemo.png">Mobile Screens</img>
        
		</h2>
		<h2 t="Building the Mobile App">
		<p>If you build <courier>madura-mobile-demo</courier> with maven in the usual way you will get a war file you can deploy and browse to, including from your mobile
		devices. But this still looks like a web application rather than a mobile application. For example you still see the URL at the top
        of the browser display. Also we cannot put this into an app store and have users install it from there. Yes we can!</p>
        <p>The key to this is a product called PhoneGap. The details of how
        to use it to package a Vaadin application for an app store are in <referenceLink t="PhoneGap"/>.</p>
        <p>But there is very little to it. In the madura-mobile-demo sources you will find a directory called <courier>cordova</courier> which
        contains the files to build the PhoneGap application. Most of this is specific to Phonegap and it documented by that product, but the
        thing you need to know for now is that this application is essentially a wrapper for the browser. Phonegap can do a lot more than that
        but this is a demo so we will keep it simple. If there is a deployed war file there must be a url somewhere, that is in the <courier>index.html</courier> file.
        There is also a <courier>config.xml</courier> file which holds the name and description of the application, the name generates the final
        file name of the apk file.</p>
        <p>The Phonegap part of the build is disabled by default and to use it you need to run the <courier>phonegap</courier> maven profile.
        But first you need to sign up to Phonegap and get a user name, password and create an application id. These need to be defined as maven properties
        <courier>phonegap-build.username, phonegap-build.password</courier> and <courier>phonegap-build.appId</courier>.</p>
        <p>This apk file is the simplest kind of application you can build, and because it is not signed it cannot be put into the app store. Only
        the Android variation lets you generate unsigned applications, which is why we are using it here. To generate signed applications you need
        to apply to the relevant app stores for an id and tell Phonegap about it. Phonegap supports builds for Apple iOS devices and several others.</p>
        </h2>
        </h1>
        <h1 t="madura-login">
        <img width="12cm" href="images/Login.png">Login Screen</img>
        <p>This sub project provides a demo-ware login facility. It uses a web fragment to provide authentication and authorization services.</p>
        <p>To configure it into an application we need to tell Spring which directories to scan. All the demos here do this in the <courier>WEB-INF/applicationContext.xml</courier> file.
        That file also defines the <courier>permissionManager</courier> bean, although we could have added it with a <courier>@Bean</courier> in the <courier>@Configuration</courier> like this:</p>
        <code><![CDATA[
@Bean(name="permissionManager")
@UIScope
public PermissionManager getPermissionManager() {
	PermissionManagerImpl ret = new PermissionManagerImpl();
	return ret;
	}
        ]]></code>
        <p>The <courier>@UIScope</courier> does the same job as the <courier>scope="vaadin-ui"</courier> on the bean definition in the context file.</p>
        <p>That is the minimum. But we can do more with security. First, we can remove the existing login mechanism on any of the demos and replace it with something else. Second,
        we can keep the existing login mechanism and reconfigure it or extend it.</p>
        <h2 t="Replacing madura-login">
        <p>The connection between madura-login and the application is deliberately loose. The login process puts some attributes into the session
        and the application code pulls them out and uses them to configure the <courier>PermissionManager</courier>. Madura uses the <courier>PermissionManager</courier>
        for all security references. So if you don't want to use madura-login you need to provide another way to configure the <courier>PermissionManager</courier>.</p>
        <p>This is easily done by supplying a bean that implements the <courier>PermissionResolver</courier> interface:</p>
        <code><![CDATA[
@Component("permissionResolver")
@UIScope
public class PermissionResolverImpl implements PermissionResolver {

	@Autowired PermissionManager permissionManager;
    
	@PostConstruct
	public void unpackPermissions() {
		WrappedSession session = VaadinService.getCurrentRequest().getWrappedSession();
    	String currentUser = (String)session.getAttribute(AuthenticationDelegate.USERNAME);
    	@SuppressWarnings("unchecked")
		Set<String> currentPermissions = (Set<String>)session.getAttribute(AuthenticationDelegate.PERMISSIONS);
    	permissionManager.setPermissionsList(currentPermissions);
    	permissionManager.setCurrentUser(currentUser);
	}
}	
        ]]></code>
        <p>This is the out-of-the-box behaviour.</p>
        <p>The class is instantiated once per session and the <courier>PostConstruct</courier> method will be run once the <courier>PermissionManager</courier>
        has been injected and is ready for further configuration with the permissions list and the user name fetched, in this case, from the
        session attributes. Using session attributes is a typical way to pass authentication information but the actual details and structure of what is passed
        varies from authentication product to authentication product. Implementing your own version with different attribute names should be fairly simple.</p>
        </h2>
        <h2 t="Reconfiguring madura-login">
        <p>You can configure the following:</p>
        <list>
        <le>Add a customised login.html file to your project's resources directory</le>
        <le>Add a customised login.css file to your project's resources/css directory</le>
        <le>Add a customised logo.gif file to your project's resources/images directory</le>
        <le>Add a customised users.csv file to your project's WEB-INF directory this holds the list of valid users, passwords and their permissions</le>
        <le>Deploy a different <courier>AuthenticationDelegate</courier> implementation as a bean</le>
        </list>
        <p>Sometimes when testing your application you can get weary of logging in over and over. Add this to your
        <courier>config.properties</courier> file:</p>
        <code><![CDATA[
nz.co.senanque.login.RequestValidatorImpl.defaultLogin:admin/admin
        ]]></code>
        <p>That will automatically log you in as user/password admin/admin. Naturally you remove this for production.</p>
        </h2>
        <h2 t="Login and Mobile">
        <p>When developing mobile applications you often need to include two UIs in the same application. The login page itself
        uses <courier>@media</courier> queries in the css file to adjust itself for different devices, specifically a Galaxy S4 and an iPad mini,
        but the adjustments are generic enough to cover more devices than that. It will also
        redirect to your application's mobile UI as well. This is controlled by another config setting:</p>
        <code><![CDATA[
nz.co.senanque.login.RequestValidatorImpl.mobilePathPrefix:mobile
        ]]></code>
        <p>This is the default setting so all you need to do is have your application's mobile UI look like this:</p>
        <code><![CDATA[
@SuppressWarnings("serial")
@Widgetset("com.vaadin.addon.touchkit.gwt.TouchKitWidgetSet")
@Theme("madura-touchkit-theme")
@SpringUI(path="mobile")
public class MaduraMobileDemoTouchKitUI extends UI {
...
        ]]></code>
        <p>The vital bit there is the <courier>@SpringUI</courier> which specifies a path. The path there must match the value in the config file.
        The widgetset being used is the default touchkit widgetset.</p>
        </h2>
        <h2 t="Extending madura-login">
        <p>Each demo includes its own version of <courier>login.html</courier> with a help link, mostly to show how it can be done
        and also to help people using the online demos. The link uses different urls for different demos.</p>
        <p>Things a production version would have to have:</p>
        <list>
        <le>A more secure user storage, you would implement this with a replacement <courier>AuthenticationDelegate</courier>. The replacement should not store
        passwords in clear text etc.</le>
        <le>A 'remember me' checkbox.</le>
        <le>Security timeout</le>
        <le>forgot password/change password. This would need to tie in with your <courier>AuthenticationDelegate</courier> implementation.</le>
        </list>
        <p>The out-of-the-box implementation has just two user/passwords: admin/admin and user/user. Admin has the ADMIN permission which is used in the rules demo.</p>
        </h2>
        </h1>
        
		<a1 t="License">
			<p>The code specific to Madura-VaadinSupport is licensed under the Apache License 2.0 <referenceLink t="Apache Licence 2.0"/>.</p>
			<p>Most of the dependent products have compatable licenses detailed in their pom files.</p>
            <p>TouchKit, which is an optional dependency, has a dual AGPL 3.0 and Commercial Vaadin Addon License (CVAL) 2.0. That
            basically means that if you are building a project compatible with AGPL you can use this for free, if you are doing
            something else you have to buy a license from Vaadin. Madura Rules, also an optional dependency, has a similar license
            arrangement.</p> 
		</a1>
		<a1 t="Release Notes">
		<note>You need Java 1.7 to compile this project.</note>
		<table width="12cm">
			<tw>12cm</tw>
        <tr>
            <th>3.1.0</th>
        </tr>
        <tr>
        	<td>Fixed several problems in login which prevented clean deloyment on Openshift.</td>
        </tr>       
        <tr>
            <th>3.0.0</th>
        </tr>
        <tr>
        	<td>Major rework/rerwite of the Madura Vaadin code.</td>
        </tr>       
        <tr>
        	<td>Supports Vaadin 7, Touchkit 4, Madura 3.0.0 and Spring 4.</td>
        </tr>       
        <tr>
        	<td>Uses more compact configuration.</td>
        </tr>       
        <tr>
        	<td>Better organisation of sub projects.</td>
        </tr>       
        <tr>
        	<td>Uses Vaadin's Spring addon rather than SpringApplicationLoader.</td>
        </tr>       
        <tr>
        	<td>Removed dependencies on Madura Bundles.</td>
        </tr>       
        <tr>
            <th>2.6.0</th>
        </tr>
        <tr>
        	<td>Just realigning the versions, including using a later version of Madura Objects and Madura Bundles.</td>
        </tr>       
        <tr>
            <th>2.5.4</th>
        </tr>
        <tr>
        	<td>Upgraded the BundleListener to properly handle bundle deletion.</td>
        </tr>       
        <tr>
            <th>2.5.3</th>
        </tr>
        <tr>
        	<td>Changed dependency on Madura Objects and Madura Bundles to 2.2.4 and 4.0.3 respectively.</td>
        </tr>       
        <tr>
            <th>2.5.2</th>
        </tr>
        <tr>
        	<td>Changes for git.</td>
        </tr>       
        <tr>
            <th>2.5.1</th>
        </tr>
        <tr>
        	<td>Subapplication caption now tries to translate 'project.name' first, then falls back to bundle name.</td>
        </tr>       
        <tr>
        	<td>Fixed confusion between buttons and checkboxes.</td>
        </tr>       
        <tr>
        	<td>Set MaxLength on text fields.</td>
        </tr>       
        <tr>
        	<td>Eliminate BeanUtils references and use MaduraObjects metadata instead. BeanUtils was giving odd results.</td>
        </tr>       
        <tr>
        	<td>More flexible handling of message source accessor, specifically when the message source may exist in a bundle
        	rather than the main application, it now gets passed around as an argument.</td>
        </tr>       
        <tr>
        	<td>Better clean up of registered fields and labels on close of session.</td>
        </tr>       
        <tr>
            <td>Changed field generations so that if no write permission we set the field to read-only. Previously it was disabled instead.</td>
        </tr>
        <tr>
            <td>Changed SubmitButtonPainter so that if you set the MaduraForm to readOnly
            then the submit button will be disabled.</td>
        </tr>
        <tr>
            <td>Updated Spring dependencies.</td>
        </tr>
        <tr>
            <th>2.5.0</th>
        </tr>       
        <tr>
            <td>Moved to maven build.</td>
        </tr>
        <tr>
            <th>2.4.1</th>
        </tr>       
        <tr>
            <td>Fixed a bad pom file. The version was incorrect.</td>
        </tr>
        <tr>
            <th>2.4</th>
        </tr>       
        <tr>
            <td>Added pom file for maven projects.</td>
        </tr>
        <tr>
            <td>Touchkit is now a compile only dependency so it is not automatically pulled from the
            repository. This is to allow more explicit handling of the Touchkit licence.</td>
        </tr>
        <tr>
            <th>2.3</th>
        </tr>       
        <tr>
            <td>Built with Java 1.7.</td>
        </tr>       
        <tr>
            <th>2.2</th>
        </tr>       
        <tr>
            <td>Changed default layout to FormLayout from VerticalComponentLayout in TouchkitMaduraForm because the latter fails to handle dynamic required fields.</td>
        </tr>       
        <tr>
            <td>Added a login mechanism for Touchkit.</td>
        </tr>       
		<tr>
			<th>2.1</th>
		</tr>		
		<tr>
			<td>Fixed problem with help screen not popping back.</td>
        </tr>       
        <tr>
            <td>Added TouchkitMaduraForm.</td>
        </tr>       
        <tr>
            <th>2.0</th>
        </tr>       
        <tr>
            <td>This is a major rework which eliminates the several factories that relied on statics and singletons to work.
            This version, with a loss of backward compatibility, improves the useability of the library
            as well as making it compatible with Vaadin's Touchkit.</td>
        </tr>       
        <tr>
            <td>Added a proper sample application showing the use of the Hibernate Container.</td>
		</tr>
		<tr>
			<th>1.9</th>
		</tr>		
		<tr>
			<td>Fixed problem with logout.</td>
		</tr>
		<tr>
			<th>1.8</th>
		</tr>		
		<tr>
			<td>Fixed problem with source never displaying from ivy</td>
		</tr>
		<tr>
			<td>Added method getMaduraPropertyWrapper() to MaduraSessionManager</td>
		</tr>
		<tr>
			<td>Fixed problem in FormatterDouble which always failed to parse a valid number</td>
		</tr>
		<tr>
			<th>1.7</th>
		</tr>
		<tr>
			<td>Clearing a field doesn't fire the rules, issue #3: fixed.</td>
		</tr>
		<tr>
			<td>Added support for pluggable applications (perspective manager).</td>
		</tr>
		<tr>
			<td>Removed use of MessageSourceAccessorFactory because it does not play well with Madura Bundles.</td>
		</tr>
		<tr>
			<td>Improved numeric parsing. Previously something like 1x000 would return 1 rather than invalid. It now
			returns invalid.</td>
		</tr>
		<tr>
			<td>Added menu item control (visibility, enabled/disabled) from rules using the same mechanism as buttons.</td>
		</tr>
		<tr>
			<td>Made some more classes Serializable.</td>
		</tr>
		<tr>
			<th>1.6</th>
		</tr>
		<tr>
			<td>Added serialisation to some classes Tomcat complains about on shutdown. There are some
			Spring classes it still complains about, though.</td>
		</tr>
		<tr>
			<td>Added default login.html in case the one in the theme is missing, also show warning. The
			access of the login.html file has been tightened up so it works on Tomcat, ie more portable.</td>
		</tr>
		<tr>
			<td>Added the generic login listener: SpringLoginListener. This uses Spring Security and handles
			unpacking the authorities and using them as permissions.</td>
		</tr>
		<tr>
			<th>1.5</th>
		</tr>
		<tr>
			<td>Fixed several issues with the formattingTable.</td>
		</tr>
		<tr>
			<td>Adjusted dependencies.</td>
		</tr>
		<tr>
			<th>1.4</th>
		</tr>
		<tr>
			<td>Handling case where we add a row and then cancel, row is removed.</td>
		</tr>
		<tr>
			<td>Fixed problem with using evict which stopped us adding new rows.</td>
		</tr>
		<tr>
			<th>1.3</th>
		</tr>
		<tr>
			<td>Boolean fields now rendered as checkbox.</td>
		</tr>
		<tr>
			<td>Submit button not disabling when required field is blanked. Fixed.</td>
		</tr>
		<tr>
			<td>Fixed NPE when login fails.</td>
		</tr>
		<tr>
			<td>Setting a required field to blank failed to disable the submit button. Fixed.</td>
		</tr>
		<tr>
			<th>1.2</th>
		</tr>
		<tr>
			<td>Simplified the binding needed in the table editor.</td>
		</tr>
		<tr>
			<th>1.1</th>
		</tr>
		<tr>
			<td>Support for @Secret fields</td>
		</tr>
		<tr>
			<td>Error handling/reporting added.</td>
		</tr>
		<tr>
			<th>1.0</th>
		</tr>
		<tr>
			<td>Initial version</td>
		</tr>
		</table>
		</a1>
	</body>
	
</doc>
