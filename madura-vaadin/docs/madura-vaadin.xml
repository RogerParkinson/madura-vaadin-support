<?xml-stylesheet type="text/xsl" href="MaduraHTML.xsl" ?>

<doc xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="http://www.madurasoftware.com/maduradocs.xsd">
	<title>
		<MainTitle>MaduraVaadinSupport</MainTitle>
		<SubTitle>User Guide</SubTitle>
		<Author>Roger Parkinson</Author>
		<Revision>$Revision: 1$</Revision>
		<image>logo.jpg</image>
		<references>
			<reference t="Spring Framework" url="http://www.springframework.org" />
			<reference t="Vaadin" url="https://vaadin.com/home"/>
			<reference t="MaduraObjects" url="https://github.com/RogerParkinson/madura-objects-parent"/>
			<reference t="MaduraRules" url="https://github.com/RogerParkinson/MaduraRules"/>
			<reference t="MaduraBundles" url="https://github.com/RogerParkinson/madura-bundles"/>
			<reference t="madura-addressbook" url="https://github.com/RogerParkinson/MaduraAddressbook"/>
			<reference t="madura-pizzaorder" url="https://github.com/RogerParkinson/MaduraPizzaOrderDemo"/>
			<reference t="madura-pizzaorder-online" url="http://pizzaorderdemo-madura.rhcloud.com/"/>
			<reference t="madura-perspectives-manager" url="https://github.com/RogerParkinson/MaduraPerspectivesManager"/>
			<reference t="madura-perspectives-manager-online" url="http://perspectivesmanager-madura.rhcloud.com/"/>
			<reference t="madura-pizzaorder-bundle" url="https://github.com/RogerParkinson/MaduraPizzaOrderBundle"/>
			<reference t="vaadin-touchkit" url="https://vaadin.com/add-ons/touchkit"/>
			<reference t="vaadin-addon" url="https://vaadin.com/directory#!authoring/edit/addon=449"/>
			<reference t="PhoneGap" url="https://vaadin.com/blog/-/blogs/packaging-vaadin-apps-for-home-screens-and-app-stores-with-phonegap"/>
		</references>
	</title>
	<body>
		<process-log/>
		<process-references/>
		<h1 t="Purpose">
		<p>MaduraVaadinSupport ties together all the back-end Madura projects (Madura Objects<referenceLink t="MaduraObjects"/>, Madura Rules<referenceLink t="MaduraRules"/>, 
		Madura Bundles<referenceLink t="MaduraBundles"/>) and delivers them with a Vaadin UI<referenceLink t="Vaadin"/>. So it is worth taking a brief moment to review what those back-ends do:</p>
		<list>
		<le>Madura Objects builds your domain objects as annotated POJOs from an XSD file (using JAXB). The resulting objects behave just like POJOs except, when configured with the Madura Objects validation
		engine, they self validate as well as maintaining field metadata such as choice lists, permissions, labels etc.</le>
		<le>Madura Rules plugs into the Madura Objects validation engine to support a rules/constraints based environment that does cross-field validation as well as deriving new values (eg total of the invoice 
		lines on this invoice). It does 'truth maintenance' which means when the data changes rules might be 'unfired', keeping the derived data always 'true'.  The rules can also operate on metadata which 
		means they can change the	list of valid choices on a choice field, make a field visible or read-only etc.</le>
		</list>
		<p>This project wraps those tools to make them easy to use in a Vaadin application. The result delivers highly dynamic applications with very little application code. For example:</p>
		<list>
		<le>You can pass a POJO to a generic form which builds display fields for all the POJO fields. Each field is automatically validated according to specifications in the XSD (eg field length, numeric range checks) and
		error messages delivered where necessary. Required fields (again, as specfied in the XSD) are noted and the submit button is disabled until they are filled in, it is also disabled if there is an
		error. The generic form can accept a list of fields so you can specify which ones you want, you don't have to have them all.</le>
		<le>All field captions are fetched from the relevant XSD label and translated to the current locale.</le>
		<le>All validations on all fields are handled automatically. That means range checks, regex checks etc, but it also
		means rules based validation if you have configured it. The application code is unaware of this.</le>
		<le>Error handling and delivery of any messages is synched with Vaadin's error message delivery and messages
		are locale translated.</le>
		<le>Permissions are enforced. If this user only has read-only permission on a field it will be rendered
		but disabled. If they do not have read permission it will not be rendered. If no permissions are specified on
		the field it will be rendered normally, so you only add permissions to fields you care about.</le>
		<le>Fields marked Secret are rendered as Password style fields.</le>
		<le>Default values, if specified in the XSD, will be loaded in the obvious way.</le>
		<le>Required fields are indicated as such. This is normally done with a red asterisk (Vaadin's default) but is customisable.</le>
		<le>The submit buttons disable themselves until all the required fields are all filled in. They also disable
		if there are any errors in the fields they are watching. Menu items are treated much the same as buttons, so a submit menu item will be disabled until the form is complete.</le>
		<le>Any appropriate Vaadin controls can be used, not just the standard ones. All the usual theme features available in ordinary Vaadin applications are still in place. The main change is the
		use of a specialised FieldFactory which can be used on any form, not just the Madura generic form.</le>
		</list>
		<p>In addition, if you have configured a rules plugin into your validation engine:</p>
		<list>
		<le>The validation can include cross field validation.</le>
		<le>Choice lists dynamically change as the available choices change.</le>
		<le>Fields may change to/from read-only or invisible as rules fire.</le>
		<le>One or more buttons may be tied to boolean fields that are, in turn, controlled by rules. These buttons
		become enabled or disabled depending on the current value of the boolean.</le>
		<le>Labels and read-only fields may contain data derived from rules. This automatically updates as the rules change the data.</le>
		</list>
		<p>Still with us? Good. In addition to all that we added some extra things that come in handy:</p>
		<list>
		<le>Support for Mobile applications using Touchkit<referenceLink t="vaadin-touchkit"/> and PhoneGap<referenceLink t="PhoneGap"/>.</le>
		<le>An extension of the Vaadin JPAContainer which supports @Transactional better. It also supports nice popup edit forms for each row. The edit forms use a validation engine.</le>
		<le>A login filter that pops a login dialog if this user is not yet logged in. We use this for demos rather than production, but it could be customised for production..</le>
		</list>
		<p>The details of how to use all this are best explained by examples.</p>
		<list>
		<le>madura-vaadin-demo: This is a basic demo of Madura working with Vaadin. Specifically Madura Objects without Madura Rules.</le>
		<le>madura-rules-demo: This is the full demo that shows Madura Objects and Madura Rules working with Vaadin.</le>
		<le>madura-address-book: Demonstrates the extended JPA container and a pop-up row editor which has Madura backind the fields.</le>
		</list>
 		<p>These demos form the basis of this documentation and we will refer to them extensively. The code here is packaged as a vaadin-addon<referenceLink t="vaadin-addon"/> available from the Vaadin site.</p>
		</h1>
		<h1 t="Common Techniques">
		<p>All the demos use Vaadin 7, Spring, Madura and Maven. We assume you are reasonably familiar with all of these.</p>
		<p>To build use: <courier>mvn install</courier></p>
		<p>To run with Jetty use: <courier>mvn jetty:run</courier> and open <courier>http://localhost:8080/</courier>. You can also run them with Eclipse WTP. We tested with Tomcat 7.</p>
		<p>To login the user/password is always admin/admin, you can also use user/user</p>
		<p>The login process is managed by the <courier>madura-login</courier><sectionLink t="madura-login"/> project. This provides a simple login facility suitable for demos simply by making it
		a maven dependency and a little configuration.</p>
        <p>As is usual in Madura Objects we have several files in the resources directory. These are mostly things like <courier>logback.xml</courier> as well as files covered in Madura Objects or Madura Rules documentation.
        But because they are so important we will mention the XSD files which define the objects. There is an entry in the maven <courier>pom.xml</courier> file that invokes <courier>madura-objects-maven-plugin</courier>
        which is just a jacket for JAXB that saves you having to configure JAXB for Madura. That generates annotated Java files from the XSD and puts them into the <courier>generated-sources/xjc</courier>
        directory. You never edit those Java file, you change the XSD and regenerate.</p>
        <p>Vaadin also has a maven plugin: <courier>vaadin-maven-plugin</courier> which generates the widgetsets.</p>
		<p>Each demo makes use of Spring Configuration in preference to Spring XML and we also make use of the Vaadin-Spring Addon. However it is simpler to allow one
		XML component because of the way the defaults work. So each project has an <courier>applicationContext.xml</courier> file in the <courier>WEB-INF</courier> directory. It looks like this 
		(excluding the headers etc for brevity):</p>
        <code><![CDATA[
...
<context:component-scan base-package="nz.co.senanque.vaadindemo, nz.co.senanque.login" />
<bean id="messageSource" class="nz.co.senanque.resourceloader.ResourceBundleMessageSourceExt">
	<property name="basenames">
		<list>
			<value>ApplicationMessages</value>
		</list>
	</property>
</bean>
</bean>
        ]]></code>
        <p>This does two things. It tells Spring to scan the application package for component beans, and the login package as well because it has components we want too. It also creates
        the message source. <courier>ApplicationMessages</courier> are the messages for the current demo. <courier>ResourceBundleMessageSourceExt</courier> is just like Spring's 
        <courier>ResourceBundleMessageSource</courier> except it can go find the properties files in various jar files by itself.</p>
        <p>But most of the Spring configuration is in the code. Each demo has a class that extends <courier>com.vaadin.ui.UI</courier> called either 
        <courier>MyUI</courier> or <courier>AddressBookUI</courier>. This contains the configuration.</p>
        <code><![CDATA[
@Theme("mytheme")
@Title("Madura Vaadin Demo")
@Widgetset("nz.co.senanque.vaadindemo.MyAppWidgetset")
@SpringUI
public class MyUI extends UI {

    @Autowired private MaduraSessionManager m_maduraSessionManager;
    @Autowired private DefaultView m_defaultView;

    @WebServlet(name = "MyUIServlet", urlPatterns = "/*", asyncSupported = true)
    public static class MyUIServlet extends SpringVaadinServlet {

		private static final long serialVersionUID = 1L;
    }

    @WebListener
    public static class MyContextLoaderListener extends ContextLoaderListener {
    	// This causes the applicationContext.xml context file to be loaded
    	// per session.
    }
...
        ]]></code>
		<p>The first three annotations are normal Spring-Vaadin things that ensure this class is loaded with the right theme etc. You can also see a static class that declares a servlet
		as well as a web listener. The listener is what loads the <courier>applicationContex.xml</courier> you saw above.</p>
		<p>There are also two auto wirings, one for the current MaduraSessionManager and one for a local class which defines most of the UI. There is
		often more than one of these classes.</p>
		<p>After that there is a static class that defines the configuration. It is worth noting that the above section is created and wired <emph>per session</emph> whereas this following section
		is <emph>per application</emph>, ie singletons except for those annotated <courier>UIScope</courier> which are session beans.</p>
        <code><![CDATA[
...
@Configuration
@EnableVaadin
@ComponentScan(basePackages = {
		"nz.co.senanque.vaadin",
		"nz.co.senanque.validationengine"})
@PropertySource("classpath:config.properties")
public static class MyConfiguration {
	
	public MyConfiguration() {
	}
   	// needed for @PropertySource
   	@Bean
   	public static PropertySourcesPlaceholderConfigurer propertyConfigInDev() {
   		return new PropertySourcesPlaceholderConfigurer();
   	}
   	@Bean(name="hints")
   	@UIScope
   	public Hints getHints() {
   		return new HintsImpl();
   	}
}
...
        ]]></code>
        <p>The things to note here are that there are more packages to scan, namely the validation engine and the components of the madura-vaadin project. We also specify a properties file which injects values
        into these scanned components. You will see the <courier>config.properties</courier> file in the resources directory and it holds those values. The <courier>hints</courier> bean is defined here
        rather than scanned so that you can replace it with your own implementation. The hints bean helps the field factory decide what kind of field to create in various circumstances. The one used
        here works just fine but you might want something different.</p>
        <p>The <courier>config.properties</courier> only needs to know what package the generated Java classes are in, like this:</p>
        <code><![CDATA[
nz.co.senanque.validationengine.metadata.AnnotationsMetadataFactory.packages=nz.co.senanque.pizzaorder.instances
		]]></code>
        <p>Next up is the <courier>init</courier> method which is called when the user session is created.</p>
        <code><![CDATA[
...
    protected void init(VaadinRequest vaadinRequest) {
    	
    	String currentUser = (String)vaadinRequest.getWrappedSession().
    		getAttribute(AuthenticationDelegate.USERNAME);
		Set<String> currentPermissions = (Set<String>)vaadinRequest.getWrappedSession().
			getAttribute(AuthenticationDelegate.PERMISSIONS);
    	m_maduraSessionManager.getPermissionManager().setPermissionsList(currentPermissions);
    	m_maduraSessionManager.getPermissionManager().setCurrentUser(currentUser);
    	this.getSession().setConverterFactory(m_maduraSessionManager.
    		getMaduraConverterFactory());
    	
    	MessageSourceAccessor messageSourceAccessor= new MessageSourceAccessor(m_maduraSessionManager.getMessageSource());
    	final String logout = messageSourceAccessor.getMessage("logout");
...
        ]]></code>
        <p>The first few lines here are fetching the login details from <courier>madura-login</courier> and transferring them to the injected <courier>MaduraSessionManager</courier>.
        This may seem a little clumsy but it is deliberate because we want to ensure there are no dependencies between Madura and <courier>madura-login</courier>. That allows
        people to use their own login mechanism. All that we really need here is a way to get the user name and the permissions.</p>
        <p>Going the other way we need to tell Vaadin about a converter factory that Madura needs.</p>
        <p>The last part is fairly ordinary Spring code that uses a <courier>MessageSourceAccessor</courier> to translate the logout string. It is interesting because it shows that
        for various headings or captions of components that are not controlled by Madura we still need to call a <courier>MessageSourceAccessor</courier> for I18n, but most of the time we don't.</p>
        <p>The last part is the logout:</p>
        <code><![CDATA[
...
private void logout() {
 	m_maduraSessionManager.close();
 	VaadinService.getCurrentRequest().getWrappedSession().invalidate();
 	getUI().close();
    String contextPath = VaadinService.getCurrentRequest().getContextPath();
    getUI().getPage().setLocation(contextPath);
}
...
        ]]></code>
        <p>This closes down the Madura session and the Vaadin session and redirects to the login page, well actually it redirects to the application but since we are no longer logged in the login page is popped up.</p>
        <p>The <courier>DefaultView</courier> class was mentioned above. It is auto wired into the <courier>MyUI</courier> class and all of the demos have one or more classes like this, so let's take a brief look at
        one of them:</p>
        <code><![CDATA[
...
@UIScope
@SpringComponent
public class DefaultView extends VerticalLayout implements MessageSourceAware {

	@Autowired private MaduraSessionManager m_maduraSessionManager;
...
        ]]></code>
        <p>The two class annotations ensure that Spring loads this as a session component, and the <courier>MaduraSessionManager</courier> is auto wired. The <courier>MaduraSessionManager</courier> is the 
        general purpose API we use to get to Madura so we need it everywhere.</p>
		<p>Now we can look inside the first demo.</p>
		</h1>
		<h1 t="madura-vaadin-demo">
		<p>The interesting things in this project are in the <courier>nz.co.senanque.vaadindemo.DefaultView</courier>. You saw it briefly in the previous section so you knowit is a session dependent bean and
		it has a <courier>MaduraSessionManager</courier> injected.</p>
		<p>It has an <courier>init</courier> method which runs once Spring has instantiated the bean and finished injecting everything. The first thing this does is create a <courier>MaduraFieldGroup</courier>. This
		class is an extension of Vaadin's <courier>FieldGroup</courier> with some added methods for Madura. Here it is used to create two buttons. The two buttons don't do much (this is a demo, remember). But how they
		are created is important.</p>
        <code><![CDATA[
...
Button cancel = m_maduraFieldGroup.createButton("button.cancel", new ClickListener(){
...
	}});
...
        ]]></code>
		<p>There is not much to this really. It creates a button, translates the name and adds the listener. But we might have used a variation on this:</p>
        <code><![CDATA[
...
Button cancel = m_maduraFieldGroup.createButton("button.cancel", "ADMIN", new ClickListener(){
...
	}});
...
        ]]></code>
        <p>In this case we added a permission. If the user does not have this permission the button will be disabled.</p>
        <p>The second button is similar:</p>
        <code><![CDATA[
...
Button submit = m_maduraFieldGroup.createSubmitButton("button.submit", new ClickListener(){
...
	}});
...
        ]]></code>
        <p>This button is a <emph>submit</emph> button. For us that means all fields in the field group that are flagged as required must have values before the button will be enabled. They also have to be valid. 
        The validation rules and the required flags are specified in the XSD file, not here, so the UI designer does not need to worry about those things. As with the previous button you could add a permission
        argument. Permissions always trump everything else so even if a user has filled in the fields correctly the submit button will not enable unless they have the permission. If you want to make one of the buttons
        the default button, ie what happens when the user presses enter, you do this:</p>
        <code><![CDATA[
submit.setClickShortcut( KeyCode.ENTER );
submit.addStyleName( ValoTheme.BUTTON_PRIMARY );
        ]]></code>
        <p>The style is optional and we've chosen the one one appropriate to Vaadin's Valo theme. If we were using a different theme we would use a different style here.</p>
        <p>Apart from buttons the only other thing of importance created by the <courier>init</courier> method is the <courier>m_panel</courier>, an empty <courier>VerticalLayout</courier>. The <courier>init</courier>
        method leaves it empty.</p>
        <p>The <courier>load</courier> method is called when we are ready to display this part of the UI. It establishes the <courier>Person</courier> object we want to back the fields. <courier>Person</courier> is,
        of course, defined in the XSD file. This is what the <courier>load</courier> method does:</p>
        <code><![CDATA[
public void load(Person person) {
	m_maduraFieldGroup.buildAndBind(m_panel,Arrays.asList(fields),new BeanItem<ValidationObject>(person));
}
        ]]></code>
		<p>The list of field names as an array in the top of this class.</p>
        <code><![CDATA[
private String[] fields = new String[]{"name","email","address","gender","startDate","amount"};
        ]]></code>
        <p>Quite a few things happen in the BuildAndBind call.</p>
        <list>
        <le>Clear the <courier>m_panel</courier> of components (in case this is not the first time we called this).</le>
        <le>Bind the <courier>person</courier> to the Madura Objects session.</le>
        <le>Loop through the <courier>fields</courier> and for each one create an actual Field component, bind it to the Madura Object and add it to the <courier>m_panel</courier>.</le>
        <le>Bind any buttons. dynamic labels and menu items.</le>
        </list>
        <p>The result is a display with several fields, complete with I18n captions, backed by the Madura Object <courier>person</courier>. The buttons etc are also bound so that Submit button will be disabled
        if the <courier>person</courier> does not have all the required fields completed. The fields are all wired with validation and the field types vary by data type, so there are three text fields,
		one drop down which is populated with choices, a date and a numeric text field.</p>
        <p>This is not the only way to achieve this, and you will see alternative approaches in subsequent demos. They are summarised in <sectionLink t="MaduraFieldGroup"/></p>
		</h1>
		<h1 t="madura-rules-demo">
		<p>This demo is more complicated, and it uses Madura Rules so there are some configuration differences too. We will look at those first.</p>
		<p>The <courier>applicationContext.xml</courier> has an extra package to scan, this is the package we put the generated rules in.</p>
		<p>Madura Rules uses a maven plugin to generate Java rules in much the same way Madura Objects generated Java objects from the XSD. When you use Madura Rules you always use Madura Objects as well,
		so we have the usual XSD file and an entry for it the <courier>pom.xml</courier>. We also have a RUL file in the resources directory. That defines the rules and there is plugin configured in the pom file
		called <courier>madura-rules-maven-plugin</courier>. That puts the rules Java into <courier>generated-sources/xjc</courier> package <courier>nz.co.senanque.pizzaorder.rules</courier> which is the
		package specified in <courier>applicationContext.xml</courier>.</p>
		<p>The <courier>choices.xml</courier> file is more interesting in this demo because it includes more choice list entries (some aren't actually used), a decision table and a constant. There is more Java code as well,
		but this is not because we added rules, it is because we added more demo.</p>
		<p>As usual there is a <courier>com.vaadin.ui.UI</courier> extension (called <courier>MyUI</courier>). It looks much the same, but we are scanning one more package: <courier>nz.co.senanque.rules</courier>
		to pick up the rules components. These are the out-of-the-box rules component classes as opposed to the generated rules classes scanned in the <courier>applicationContex.xml</courier> file. Other than that
		all this class does is create a <courier>TabSheet</courier> on which it places the injected UI components so we will look a those one by one.</p>
		<p>An important point to notice here is that aprt from adding those directories to be scanned the code is comletely unaware of the rules.</p>
		<h2 t="CustomerView">
		<p>This is labelled 'Customer' on the UI (unless you are using the French version). It looks a bit like the first demo but with fewer fields and more buttons.</p>
		<p>The code makes use of the <courier>MaduraForm</courier> class which, because it is based on Vaadin's <courier>Form</courier> is deprecated. It is still useful, though, as you'll see.</p>
		<p>The <courier>enter</courier> method binds the object. This time we don't have to create the fields because the form handles that automatically based on the list of fields we set so all we need is:</p>
        <code><![CDATA[
customerForm.setItemDataSource(new BeanItem<Customer>(m_customer));
        ]]></code>

		<p>Like the <courier>MaduraFieldGroup</courier> you can use the <courier>MaduraForm</courier> to create buttons, with the same options and functionality. In this example we show a different sort of button.</p>
        <code><![CDATA[
Button bmi = customerForm.createFieldButton("button.bmi", "dynamic","ADMIN", new ClickListener(){
        ]]></code>
        <p>There is a boolean field called <courier>dynamic</courier> in the <courier>Customer</courier> object and this creates a button that is disabled or enabled depending on whether <courier>dynamic</courier>
        is false or true. This would not be all that useful if nothing changed the value of <courier>dynamic</courier>. but there is a rule in the RUL file:</p>
        <code><![CDATA[
rule: Customer "dynamic"
{
	if (name == "fred")
	{
		dynamic = true;
	}
}
        ]]></code>
        <p>This may be fairly obvious, but if it is not then you can find more details in the Madura Rules documentation. If we enter 'fred' into the <courier>name</courier> field the rules will fire and set
        <courier>dynamic</courier> to true, and that will cause the button to enable, unless this user doesn't have the ADMIN permission. This example should give you a feel for how the operation of the rules
        is detached from the UI code. The UI knows about a field called <courier>dynamic</courier>, it does not know about the rule. Similarly the rule knows about <courier>dynamic</courier> but it knows nothing about
        the UI. Yet a change from the rules propagates to the UI. We will see this a lot.</p>
        <p>Just after we created the <courier>MaduraForm</courier> we set the field list into it. This list is turned into fields with captions on a <courier>VerticalLayout</courier>. All it needs after that is an actual object
        and that is set in the <courier>enter</courier> method.</p>
        <p>The <courier>BMI</courier> button has a a listener attached that actually does something:</p>
        <code><![CDATA[
m_oneFieldWindowFactory.createWindow(m_customer, "bmi",ValoTheme.BUTTON_PRIMARY);
        ]]></code>
		<p>This invokes the directed questioning mode of the rules. What happens is quite complex, but this is all you need to use it. We pass the object, it has to be a Madura Object of course, ie generated from the XSD,
		the name of a property on the object and, optionally, a style for a submit button. The rules engine will look for rules that output that property and try and work out a value using them. Each time it finds
		it needs more information it will prompt for it. In this  case there is a rule:</p>
        <code><![CDATA[
formula: Customer "BMI"
{
	bmi = weight / (height * height);
}
        ]]></code>
        <p>So it asks for weight and height on two different pop-up windows. But it is more complicated than that. Some people like to give these measurements in imperial units, some in metric, and they don't know, say, 
        their height in metres. But that is okay. You can say you don't know and it will ask for feet then inches (two prompts). This feature can be used to simplify complicated input sequences that may need only a few
        relevant inputs, depending on the contex. If the property is already filled in, perhaps the height was obtained earlier, then it knows not to ask for it.</p>
		</h2>
		<h2 t="CustomerView2">
		<p>This is labelled 'C2' on the TabSet. It is functionally the same as the Customer tab but shows a different way of doing it. In this case the <courier>MaduraFieldGroup</courier> is used and the fields are created explicitly then
		bound to the <courier>MaduraFieldGroup</courier>. The buttons are created by calls to the <courier>MaduraFieldGroup</courier> instead of the <courier>MaduraForm</courier> but the same thing happens. THis approach
		allows you full control over what kind of fields you want and where you want to position them. For example the <courier>ComboBox</courier> might be changed to a
		<courier>TextBox</courier> if we wanted (though we probably don't want to because we like the drop down choice list).</p>
		<p>As before the <courier>enter</courier> method binds the object. And as before we don't have to create the fields here because that is already done.</p>
		</h2>
		<h2 t="CustomerView3">
		<p>This is labelled 'C3' on the TabSet. It is almost identicle to C2 but instead of buttons it uses a <courier>MenuBar</courier>. This is done much the same way as buttons and the submit menu item
		enables and disables in the same way. Field buttons (eg the BMI button) are not provided for menu items so this one is a bit simpler.</p>
		</h2>
		<h2 t="OrderView">
		<p>The order view is labelled 'Order' on the TabSet. This one does a little order entry function, like a shopping cart. We are ordering pizza but we need to say what kind of topping, size and base
		we want. And not all combinations are allowed. As we order pizzas they appear in the table on the order view.</p>
		<p>In this view we use a <courier>MaduraFieldGroup</courier> to display the status of the order in  two labels. The interesting thing about this is that instead of using input fields, which
		you have already seen, these components are labels and they are dynamic as we shall see. If we get the <courier>MaduraFieldGroup</courier> (or the <courier>MaduraForm</courier>) to create the fields
		it will always create input fields because it doesn't know any better. So this is an example of adding customisation.</p>
		<p>The table is a <courier>FormattingTable</courier> which extends Vaadin's table to handle I18n headings and formating numerics. There are two columns on this table and one ofthem is numeric.
		To set it up all we need to do is name the properties we want to display ("description","-amount") and add a minus sign to the amount to right justify it. And we also name the headings ("Description","Amount"). 
		Those headings will be used as is if there is no resource translation, but if there is the translation will be used.</p>
		<p>There are two buttons which popup two windows: 'Add Item' and 'Add Item 2'. Each of these create an order item, but they do it two different ways.</p>
		<h3 t="PizzaWindow">
		<p>This uses a <courier>MaduraForm</courier> to present the fields on the <courier>Pizza</courier> object. The code is similar to Customer view. It is worth running the demo at this point to see what it does.
		You can see the three fields: Base, Topping, Size. Because only some combinations are valid you will find that as you pick options in, say, the Topping field, and list of options on the Size field will change, and vice versa.
		It doesn't matter what order you pick them. This is driven by the decision table in <courier>choices.xml</courier>. It does not have to be hard coded XML either, the values can be pulled from external sources such
		as a database. How to do that is in the Madura Rules documentation.</p>
		<p>The other thing you will see when picking options is that the amount field, which is read only, will get a value and a new field 'testing' will appear. This is because of rules like this:</p>
        <code><![CDATA[
rule: Pizza "p2"
{
	if (size == "Small")
	{
		readonly(testing);
		activate(testing);
		amount = 10;
	}
}
        ]]></code>
        <p>The 'testing' field varies from inactive, active (ie visible), read-only, read-write and required. A description field displays the concatenation of the base, topping and size fields.</p>
        <p>As usual there is a submit button on the display and the submit button is aware of whether the 'testing' field is required and not filled in, or not required, so it can enable and disable accordingly.</p>
        <p>Once you click the submit button the pizza is added to the order, which means it displays in the shopping cart. The labels at the top of the Order view will change. Previously they said 'Shopping cart is empty'
        and a value of zero. Once you add a pizza it will say '1 items in cart' and the sum of the pizza values. How does that happen? Where is the code?</p>
        <p>You probably guessed it is in the rules.</p>
        <code><![CDATA[
rule: Order "shoppingcartsize"
{
	if (count(pizzas) > 0)
	{
		orderStatus = format("shopping.cart.status",count(pizzas));
	}
}
rule: Order "shoppingcartsize"
{
	if (count(pizzas) == 0)
	{
		orderStatus = format("shopping.cart.status.empty",0);
	}
}
        ]]></code>
        <p>It relies on two resource strings:</p>
        <code><![CDATA[
shopping.cart.status.empty=Shopping cart is empty
shopping.cart.status={0} items in cart
        ]]></code>
		<p>'pizzas' is a field on the Order which holds a list, and there are a number of built in functions that handle lists. What about the total? Yes, another rule:</p>
        <code><![CDATA[
formula: Order "sum"
{
	amount = sum(pizzas.amount); 
}
        ]]></code>
        <p>Again, the rules do not know about the UI and the UI does not know about the rules, but the values automatically update. This demo does not provide a way to delete pizzas but if it did the total
        an the status would update appropriately because the rules know to re-fire when the data they worked with changes.</p>
		</h3>
		<h3 t="PizzaWindow2">
		<p>This also configures a pizza and it looks much the same as the PizzaWindow. The differences are that the way the fields are defined is different and the description field is a label rather than a text field. It makes use
		of Vaadin's <courier>PropertyId</courier> annotation. When these are used we can call the <courier>buildAndBindMemberFields</courier> method to find and bind them.</p>
		</h3>
		</h2>
		</h1>
		<h1 t="madura-address-book">
		<p>This demo is all about displaying and editing rows from a database in a table. It uses Madura Objects but not Madura Rules. It does use the madura-tableeditor so that needs to be specified as a
		maven dependency and the <courier>nz.co.senanque.vaadin.tableeditor</courier> package has to be scanned so that is added to the <courier>ComponentScan</courier> in the <courier>AddressBookUI</courier>
		class.</p>
		<p>We also define beans in the <courier>MyConfiguration</courier> class: a table layout for persons and for trees.</p>
		<p>The <courier>nz.co.senanque.addressbook.jpa</courier> package defines a data source and demo code to load hard coded values into an in-memory H2 database.</p>
		<p>There is actually very little code in this demo because it is driven from the data structures. Once the table is loaded and visible you can right click to see a context menu
		giving options to edit, add or delete records. When adding or editing you have a Madura-backed Vaadin form with the usual validation and dynamic submit button you have seen in the other demos. It does
		not use Madura Rules but if it did there would be no change to the code except for some extra packages to scan.</p>
		</h1>
		<h1 t="MaduraFieldGroup and MaduraForm">
		<p>Most of the demos make use of <courier>MaduraFieldGroup</courier> in various ways, and the ones that do not use <courier>MaduraField</courier>. How do you know what technique to use?</p>
		<p>Bear in mind there are two distinct phases that are always present. The first phase is the initialise phase. This is called once at application startup or, more usually, at session startup. The second phase
		is when we have an object such as a person, a customer or maybe a pizza, to bind to. This might be called multiple times as we operate on different customer or different pizzas.</p>
		<h2 t="MaduraForm">
		<p><courier>MaduraForm</courier> is based on Vaadin's <courier>Form</courier> which is deprecated, a possible reason not to use it. <courier>Form</courier>, and therefore <courier>MaduraForm</courier> is
		a <courier>Component</courier> which can be added to the display. You normally let the <courier>Form</courier> create its own fields and position them where it likes, usually in a vertical layout.</p>
		<p>The steps you perform to use <courier>MaduraForm</courier> are:</p>
		<list>
		<le>Initialise it with the constructor passing <courier>MaduraSessionManager</courier>. You can pass an optional layout in the constructor as well and this is what the created fields will be added to. The default is a vertical layout
		but you do have more options than that.</le>
		<le>Set the list of field names using <courier>setFieldList</courier>. The fields will be created when there is an object bound. If you set an invalid name it will be ignored without error.</le>
		<le>create any buttons you want using the form methods and position them where you like.</le>
		</list>
		<p>That was the initialisation phase. For the bind phase use <courier>setItemDataSource</courier>, to set a data source object. This triggers the creation of the fields.</p>
		</h2>
		<h2 t="MaduraFieldGroup Auto Create">
		<p>The <courier>MaduraFieldGroup</courier> is the (non-deprecated) replacement to <courier>MaduraForm</courier>, which parallels the developments at Vaadin. The essential difference in the new class is that it
		is <emph>not</emph> a component. You get to create the fields yourself and bind them. At least that seems to be Vaadin's intention, but we rather like passing a list of fields and having them created and placed
		for us. The first step in the initialisation phase is to get a new <courier>MaduraFieldGroup</courier>:</p>
        <code><![CDATA[
m_maduraFieldGroup = m_maduraSessionManager.createMaduraFieldGroup();
        ]]></code>
        <p>The create an empty <courier>Layout</courier>. The auto created fields will be placed on this layout.</p>
        <p>Create any buttons and menu items.</p>
        <p>The initialisation phase it done. When you have a object you want to bind to it you do this:</p>
        <code><![CDATA[
m_maduraFieldGroup.buildAndBind(m_panel,fields,new BeanItem<ValidationObject>(person));
        ]]></code>
		<p>This creates the fields from the list passed, adds them to your layout (<courier>m_panel</courier>) and binds them all to the object (<courier>person</courier>). It also binds any
		buttons and/or menu items you created. When you are done you should call <courier>unbind</courier> to release the resources.</p>
		<p>The <courier>hints</courier> bean controls how auto-created fields are supplied. The default bean is class <courir>nz.co.senanque.vaadin.HintsImpl</courir>. You could, for example, supply an extension of that
		class instead with a modified <courier>getDateField</courier> that supplies a differently configured date field and so on.</p>
		<p>The advantage of this approach is that you do not have to know much about the object being displayed, just the list of field names. Even that can be derived on the fly so you can make a very generic display
		that adapts to the current object. The disadvantage is that you have little control of where the fields are actually placed.</p>
		</h2>
		<h2 t="MaduraFieldGroup Explicit Create">
		<p>This is still using <courier>MaduraFieldGroup</courier> but the code explicitly creates the fields and adds them to some layout. You have complete control over what kinds of fields you create and
		how you position them. You also need to call the <courier>MaduraFieldGroup</courier> method <courier>bind</courier> like this:</p>
       <code><![CDATA[
fieldGroup.bind(nameField, "name");
        ]]></code>
        <p>You just pass a field you already created and a field name. Do this for every field. An important point to note is that the field factory used in the auto create approach will normally generate input fields
        such as <courier>TextBox</courier> and <courier>ComboBox</courier>. Perhaps you want to use a <courier>Label</courier> instead because you only ever want to display the value. Using the explicit create approach
        you can easily do this because you get to decide the field type.</p>
		<p>You still use the same methods to create buttons etc.</p>
		<p>At bind time this is all you need:</p>
       <code><![CDATA[
fieldGroup.setItemDataSource(new BeanItem<Customer>(customer));
        ]]></code>
        <p>There is a variation on this that uses Vaadin's <courier>@PropertyId</courier> annotations. Using this you create the fields explicitly as before but you annotate them like this:</p>
       <code><![CDATA[
@PropertyId("base")
private ComboBox base = new ComboBox();
@PropertyId("topping")
private ComboBox topping = new ComboBox();
@PropertyId("size")
        ]]></code>
        <p>You do a lot more at bind time with this variation. Once you have an object to bind to you do this:</p>
       <code><![CDATA[
maduraFieldGroup = new MaduraFieldGroup(getMaduraSessionManager());
maduraFieldGroup.setItemDataSource(beanItem);
maduraFieldGroup.buildAndBindMemberFields(this); // This discovers the @PropertyId fields on this object and binds them
 	
// Now we have to add the fields to the panel
formLayout.addComponent(base);
formLayout.addComponent(topping);
formLayout.addComponent(size);
        ]]></code>
        <p>We add the buttons in the same way as usual (but at bind time) and we are done. The main advantage of this approach is that you can use Vaadin's form designer which relies on the <courier>@PropertyId</courier> annotations.
        We don't get much use out of the form designer ourselves so this may not be a compelling advantage.</p>
		</h2>
		</h1>
		<h1 t="Table Editor">
		<p>The table editor is used in the address book demo. It is a bit more complicated to configure so this section details that.</p>
		<p>First there needs to be a database defined. The address book demo only uses one database, which is more common than multiple
		database connections. The connection is defined in the <courier>ConfigJPA</courier> class. If defined three beans: a data source, and entity manager factory and a transaction manager. Because this is a demo
		we've used an in-memory H2 database and it gets loaded with data by the <courier>LoadJPA</courier> bean. Naturally all this would
		be reworked for a production system.</p>
		<p>The next class to look at is <courier>ConfigContainer</courier>. This class defines the two containers used in the demo: one for
		the peopel and one for the trees. Apart from their data types and bean names these beans are the same, and because they are so similar we
		need to give them names to make sure the right bean is injected into the right place. Do not be tempted to put container beans into
		your <courier>ConfigJPA</courier> file. These beans need the <courier>EntityManager</courier> established and that is actually
		done in the <courier>ConfigJPA</courier>, which means you cannot use it in that class hence the need for the <courier>ConfigContainer</courier>
		class.</p>
		<p>All of the above beans are singletons. The rest of this is tied to a session.</p>
		<p>In <courier>AddressBook.MyConfiguration</courier> the two container are injected using their names. Thry each help define the
		<courier>personTableLayout</courier> and <courier>treeTableLayout</courier> beans. Those are the actual table layouts, they are Vaadin
		components and they are added to the <courier>PersonView</courier> and <courier>TreeView</courier> tabs</p>.
		<p>The container effectively defines a database query on a table. In the demo case the query is for all records but it can be refined
		in various ways. See the Vaadin documentation for that.</p>
		</h1>
        <h1 t="Mobile Applications">
        <h2 t="Touchkit">
        <p>Touchkit is an addon product produced by Vaadin to enable 'touch' devices like phones and tablets, so this
        is what you need for a mobile application. There is a lot to Touchkit that we will not cover here (just as there
        is a lot to Vaadin that we don't cover). But we will do the basics and show it working with Madura.</p>
        <p>Touchkit is a dual licence product. If your project qualifies for AGPL then you use the free agpl version. If not
        you need to buy a licence from Vaadin. Our demos are AGPL so they use the agpl version.</p>
        <p>At the time of writing the version of Touchkit we need was not in the maven central repository so there are some
        repository references in the pom file for the demos.</p>
        <p>But the demo project does not refer to Touchkit directly. There is a <courier>madura-vaadin-touchkit</courier>library that
        adds some Touchkit specifics to help Madura, and that has the dependency</p>
        <code><![CDATA[
<dependency>
	<groupId>com.vaadin.addon</groupId>
	<artifactId>vaadin-touchkit-agpl</artifactId>
	<version>4.0.0</version>
	<type>jar</type>
</dependency>
        ]]></code>
        <p>But what you will find in the <courier>madura-mobile-demo</courier> is this:</p>
        <code><![CDATA[
<dependency>
	<groupId>nz.co.senanque</groupId>
	<artifactId>madura-vaadin-touchkit</artifactId>
</dependency>
        ]]></code>
        </h2>
		<h2 t="The Demo">
		<p>The <courier>madura-rules-demo</courier> project is the one we are looking at. This combines <emph>two</emph> UIs: a desktop UI
		and a mobile UI. The two UIs do mush the same thing, they certainly have the same underlying objects and rules (using Madura Objects)and Madura Rules, of course).
		Part of the point is to show that while you might have to deliver a different UI for a different technology you do not
		have to re-engineer the object and rules to doit.</p>
		<p>The desktop UI is called the fallback UI in this demo because the convention is that the mobile UI has to fall back to the desktop when it is
		not invoked by a mobile device. In practice it seems more like the other way around but there are multiple ways to achieve this
		and this demo uses just one ofthose ways.</p>
		<p>The <courier>MaduraMobileFallbackUI</courier> is essentially no different from the UI class in the other demos. It is
		an extention of the <courier>com.vaadin.ui.UI</courier> class and has similar annotations. The one thing you might find puzzling there is
		that the various static classes that define the web servlet, web listener and Spring configuration are missing.
		They are in the mobile UI class. There have to be only one instance of these
		in the application and in this case the one isntance is in the other class. But
		it does not matter where they are as long as they are present somewhere.</p>
		<p>The more insteresting class at this point is the <courier>MaduraMobileDemoTouchKitUI</courier> class.</p>
		<p>The first thing to notice abut this class is that the static classes are present here, but the
		servlet class extends <courier>SpringAwareTouchkitServlet</courier>. This implements some things needed for
		Touchkit to work correctly with Spring. The class is adapted from Matti Tahvonen's version. Matti Tahvonen
		works for Vaadin.</p>
		<p>The next thing to notice is the annotations on the UI are a little different.</p>
        <code><![CDATA[
@Widgetset("org.madura.mobile.demo.gwt.MaduraMobileDemoWidgetSet")
@Theme("mytouchkit")
@SpringUI(path="mobile")
public class MaduraMobileDemoTouchKitUI extends UI {
...
        ]]></code>
        <p>The theme is one derived from the Touchkit theme, which is different from the desktop theme. Touchkit requires its own theme
        and we've added a small addition to it to make numeric fields justify right. This means you need the theme definition in the VAADIN
        directory.</p>
        <p>To get to the mobile UI there needs to be a <courier>/mobile</courier> added to the URL. This is
        actually done for us by the login sequence is you are using <courier>madura-login</courier>, but if your application
        uses something else instead you will need to have it redirect to the right UI.</p>
        <p>The rest of the UI, including the classes it invokes are much the same as the desktop UI except that there
        are some Touchkit specific controls used such as <courier>NavigationManager</courier>. You can use the same
        techniques for creating and binding objects to your UI. When it creates UI fields for you a different field factory
        is invoked to supply Touchkit fields rather than desktop ones.</p>
        <p>That brings us to the last thing to notice about the UI class namely the definition of the <courier>hints</courier>
        bean. In the other demos this just returned <courier>HintsImpl</courier> but here we need to make a decision about what
        hints we want because they are different. As with the other demos this gives youthe opportunity to customise the hints
        by supplying your own hints classes.</p>
		</h2>
		<h2 t="Building the Mobile Version">
		<!-- TODO -->
		</h2>
        <note>The mobile specific features depend on Vaadin's Touchkit and
        while it works perfectly fine, the version it works with is not in the maven central repositor at the time of writing. The version that <emph>is</emph>
        in the library requires an upgrade to Vaadin 7 (currently version 6), which is yet to be done. So the simplest
        intermediate solution it to add an explicit repository to the pom file until we can work through the V7 upgrade. The Touchkit
        product is an optional dependency, so may not be needed if your project does not need mobile features.</note>
        <p>Vaadin offer an add-on product called the vaadin-touchkit<referenceLink t="vaadin-touchkit"/> which allows you to build applications that look and feel like
        they are native mobile applications running on iOS or Android. The product is licensed as APGL but you can buy a commercial licence from Vaadin if that applies
        to your project.</p>
        <p>The people at Vaadin can do a better job of selling this concept than I can but one of the obvious advantages is
        that you can write your application just once and deploy it across multiple mobile platforms. It actually runs in the
        browser on the mobile device, but it still has access to local settings like GPS.</p>
        <p>To include the touchkit library in your project you will need something like this in your ivy file:</p>
        <code><![CDATA[
<dependency>
	<groupId>com.vaadin.addon</groupId>
	<artifactId>vaadin-touchkit-agpl</artifactId>
	<type>jar</type>
</dependency>
        ]]></code>
        <p>or for a maven pom file:</p>
        <code><![CDATA[
<dependency>
    <groupId>com.vaadin.addon</groupId>
    <artifactId>vaadin-touchkit-agpl</artifactId>
    <version>2.1.3</version>
    <scope>provided</scope>
</dependency>
        ]]></code>
        <p>The precise name of the touchkit artifact id varies depending on the licence you are using. The version shown is the
        one that madura has been tested with.</p>
        <p>To use Vaadin Touchkit with Madura is quite trivial. The pizza order demo supports both mobile and non mobile. This is
        from its web.xml file:</p>
        <code><![CDATA[
<servlet>
    <servlet-name>pizzaorder</servlet-name>
    <servlet-class>com.vaadin.addon.touchkit.server.TouchKitApplicationServlet</servlet-class>
    <init-param>
        <description>Vaadin application class to start</description>
        <param-name>application</param-name>
        <param-value>nz.co.senanque.pizzaordermobile.PizzaorderMobile</param-value>
    </init-param>
    <init-param>
        <description>Application widgetset</description>
        <param-name>widgetset</param-name>
        <param-value>nz.co.senanque.pizzaordermobile.widgetset.PizzaordermobileWidgetset</param-value>
    </init-param>
    <init-param>
        <param-name>fallbackApplication</param-name>
        <param-value>nz.co.senanque.pizzaorder.PizzaOrder</param-value>
    </init-param>
    <init-param>
        <param-name>fallbackWidgetset</param-name>
        <param-value>com.vaadin.terminal.gwt.DefaultWidgetSet</param-value>
    </init-param>
    <init-param>
        <param-name>productionMode</param-name>
        <param-value>false</param-value>
    </init-param>
</servlet>
        ]]></code>
        <p>Touchkit applications need a variation on the usual Vaadin servlet. This example shows the mobile Application
        class and the fallback Application class. The fallback is invoked if the browser isn't derived from webkit. If you
        want to try this out on a desktop use Chrome, which is a webkit browser, and it will show the mobile interface.
        Firefox will show you the desktop interface.</p>
        <p>Touchkit has its own NavigationManager which provides similar functionality as the ViewManager used by the desktop. Rather
        than rewrite the Vaadin demos for that this demo simplifies the pizza demo down to just two pages: the login page and the
        pizza configuration page. Also the login functionality in Touchkit is less rich than the desktop version so we implemented
        our own login form.</p>
        <p>Because of these differences the navigation code is trivial and it is coded into the Application class. Vaadin requires that
        this class extends <courier>com.vaadin.addon.touchkit.ui.TouchKitApplication</courier> and some variations in the
        layout make it necessary for you to use <courier>nz.co.senanque.vaadinsupport.TouchkitMaduraForm</courier> rather than
        <courier>nz.co.senanque.vaadinsupport.MaduraForm</courier>. Otherwise the code is the same. Madura Rules will, as normal,
        dynamically adjust the form as user inputs determine other fields are required etc. The drop down lists on select boxes
        will adjust to only display valid options and the buttons will disable and enable appropriately.</p>
        <img   href="images/PizzaOrderMobile.png">Mobile Demo</img>
        <p><figureLink t="Mobile Demo"/> shows the result and you can see it for yourself if you access the pizza order demo<referenceLink t="madura-pizzaorder"/> with the
        Chromium browser (or a mobile device). Remember if you use a FireFox browser you will see the standard UI.</p>
        <p>There is a minor difference in the login API. Rather than simply implement Vaadin's com.vaadin.ui.LoginForm.LoginListener we have added a 
        nz.co.senanque.vaadinsupport.viewmanager.TouchLoginListener because the LoginListener needs a protected class.
        TouchLoginListener does not, allowing us to call it from TouchLoginForm. If com.vaadin.ui.LoginForm rendered under Touchkit this
        would be unnecessary, however it does not so the solution is to use TouchLoginForm, or some varation on that if you don't like
        the way it formats.</p>
        <p>But this still looks like a web application rather than a mobile application. For example you still see the URL at the top
        of the display. Also we cannot put this into an app store and have users install it from there. Yes we can!</p>
        <p>The key to this is a product called PhoneGap which can do a lot more than we need at the moment. The details of how
        to use it to package a Vaadin application for an app store are in <referenceLink t="PhoneGap"/>.</p>
        <p>But there is very little to it. In the pizza order demo sources you will find a directory called PhoneGap which
        contains an icon and two xml files.</p>
        <code><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<widget xmlns		= "http://www.w3.org/ns/widgets"
	xmlns:gap	= "http://phonegap.com/ns/1.0"
	id		= "nz.co.senanque.pizzaordermobile"
	version 	= "1.0.0">

	<name>Pizza Order Demo</name>

	<description>
		Demonstrates a wrapped Vaadin App that uses Madura
	</description>

	<!-- I have not set this up in github 'cos it is a trivial copy of mstahv's version -->
	<author href="http://mstahv.github.com"
		email="roger.parkinson35@gmail.com">
		Roger Parkinson
	</author>

	<icon src="astrolab-icon.png" gap:role="default" />

	<feature name="http://api.phonegap.com/1.0/network"/>
	
	<!-- These rules lets demo.vaadin.com take over the web view created by cordova/phonegap -->
	<preference name="stay-in-webview" value="true" />
	<access origin="http://pizzaorder.cloudfoundry.com/" />

</widget>
        ]]></code>
        <p>That's the first file (config.xml). It mostly just tells the 'app' to point to the URL. The second file (index.xml) is even shorter</p>
        <code><![CDATA[
<!doctype html>
<html>
    <head>
        <title>Pizza Order Demo</title>
        <script type="text/javascript">
        function redirectToHostedApp() {
            window.location = "http://pizzaorder.cloudfoundry.com//";
        }
        </script>
    </head>
    <body onload="redirectToHostedApp();">
    </body>
</html>
        ]]></code>
        <p>To build an app you zip these files up and upload them to the PhoneGap site. It will generate apps for all the major platforms.
        Some of those platforms require you to set up certificates for security reasons, especially if you want to put something
        in an app store. But you can generate an Android apk file suitable for side loading with none of that.</p>
        <p>The apk file for pizza order is in the downloads for the pizza order project.</p>
        <p>Date controls are implemented as ordinary text boxes in the demo because there was no useable Touchkit widget that would
        handle date input. The next version of Touchkit may have this in place.</p>
        </h1>
        <h1 t="madura-login">
        <p>This sub project provides a demo-ware login facility. It uses a web fragment to provide authentication and authorization services.</p>
        <p>To configure it into an application we need to tell Spring which directories to scan. All the demos here do this in the <courier>WEB-INF/applicationContext.xml</courier> file.</p>
        <p>That is the minimum. But we can do more with security. First, we can remove the existing login mechanism on any of the demos and replce it with something else. Second,
        we can keep the existing login mechanism and reconfigure it or extend it.</p>
        <h2 t="Replacing madura-login">
        <p>The connection between madura-login and the application is deliberately loose. The login process puts some attributes into the session
        and the application code pulls them out and uses them to configure the <courier>PermissionManager</courier>. Madura uses the <courier>PermissionManager</courier>
        for all security references. So it you don't want to use madura-login you need to provide another way to configure the <courier>PermissionManager</courier>.</p>
        <p>This is easily done by supplying a bean that implements the <courier>PermissionResolver</courier> interface:</p>
        <code><![CDATA[
@Component("permissionResolver")
@UIScope
public class PermissionResolverImpl implements PermissionResolver {

	@Autowired PermissionManager permissionManager;
    
    @PostConstruct
	public void unpackPermissions() {
		WrappedSession session = VaadinService.getCurrentRequest().getWrappedSession();
    	String currentUser = (String)session.getAttribute(AuthenticationDelegate.USERNAME);
    	@SuppressWarnings("unchecked")
		Set<String> currentPermissions = (Set<String>)session.getAttribute(AuthenticationDelegate.PERMISSIONS);
    	permissionManager.setPermissionsList(currentPermissions);
    	permissionManager.setCurrentUser(currentUser);
	}
}	
        ]]></code>
        <p>This is the out-of-the-box behaviour.</p>
        <p>The class is instantiated once per session and the <courier>PostConstruct</courier> method will be run once the <courier>PermissionManager</courier>
        has been injected and is ready for further configuration with the permissions list and the user name fetched, in this case, from the
        session attributes. Using session attributes is a typical way to pass authentication information but the actual details and structure of what is passed
        varies from authentication product to authentication product. Implementing your own version with different attribute names should be fairly simple.</p>
        </h2>
        <h2 t="Reconfiguring madura-login">
        <p>You can configure the following:</p>
        <list>
        <le>Add a customised login.html file to your project's resources directory</le>
        <le>Add a customised login.css file to your project's resources/css directory</le>
        <le>Add a customised logo.gif file to your project's resources/images directory</le>
        <le>Add a customised users.csv file to your project's WEB-INF directory this holds the list of valid users, passwords and their permissions</le>
        <le>Deploy a different <courier>AuthenticationDelegate</courier> implementation as a bean</le>
        </list>
        <p>Sometimes when testing your application you can get weary of logging in over and over. Add this to your
        <courier>config.properties</courier> file:</p>
        <code><![CDATA[
nz.co.senanque.login.RequestValidatorImpl.defaultLogin:admin/admin
        ]]></code>
        <p>That will automatically log you in as user/password admin/admin. Naturally you remove this for production.</p>
        </h2>
        <h2 t="Login and Mobile">
        <p>When developing mobile applications you often need to include two UIs in the same application. The login page itself
        uses <courier>@media</courier> queries to adjust itself for different devices, specifically a Galaxy S4 and an iPad mini,
        but the adjustments are generic enough to cover more devices than that. It will also
        redirect to your application's mobile UI as well. This is controlled by another config setting:</p>
        <code><![CDATA[
nz.co.senanque.login.RequestValidatorImpl.mobilePathPrefix:mobile
        ]]></code>
        <p>This is the default setting so all you need to do is have your application's mobile UI look like this:</p>
        <code><![CDATA[
@SuppressWarnings("serial")
@Widgetset("org.madura.mobile.demo.gwt.MaduraMobileDemoWidgetSet")
@Theme("mytouchkit")
@SpringUI(path="mobile")
public class MaduraMobileDemoTouchKitUI extends UI {
...
        ]]></code>
        <p>The vital bit there is the <courier>@SpringUI</courier> which specifies a path. The path there must match the value in the config file.</p>
        </h2>
        <h2 t="Extending madura-login">
        <p>Things a production version would have to have:</p>
        <list>
        <le>A more secure user storage, you would implement this with a replacement <courier>AuthenticationDelegate</courier>. The replacement should not store
        passwords in clear text etc.</le>
        <le>A 'remember me' checkbox.</le>
        <le>Security timeout</le>
        <le>forgot password/change password. This would need to tie in with your <courier>AuthenticationDelegate</courier> implementation.</le>
        </list>
        <p>The out-of-the-box implementation has just two user/passwords: admin/admin and user/user. Admin has the ADMIN permission which is used in the rules demo.</p>
        </h2>
        </h1>
        
		<a1 t="License">
			<p>The code specific to Madura-VaadinSupport is licensed under the Apache License 2.0 <referenceLink t="Apache Licence 2.0"/>.</p>
			<p>Most of the dependent products have compatable licenses detailed in their pom files.</p>
            <p>TouchKit, which is an optional dependency, has a dual AGPL 3.0 and Commercial Vaadin Addon License (CVAL) 2.0. That
            basically means that if you are building a project compatible with AGPL you can use this for free, if you are doing
            something else you have to buy a license from Vaadin. Madura Rules, also an optional dependency, has a similar license
            arrangement.</p> 
		</a1>
		<a1 t="Release Notes">
		<note>You need Java 1.7 to compile this project.</note>
		<table width="12cm">
			<tw>12cm</tw>
        <tr>
            <th>2.6.0</th>
        </tr>
        <tr>
        	<td>Just realigning the versions, including using a later version of Madura Objects and Madura Bundles.</td>
        </tr>       
        <tr>
            <th>2.5.4</th>
        </tr>
        <tr>
        	<td>Upgraded the BundleListener to properly handle bundle deletion.</td>
        </tr>       
        <tr>
            <th>2.5.3</th>
        </tr>
        <tr>
        	<td>Changed dependency on Madura Objects and Madura Bundles to 2.2.4 and 4.0.3 respectively.</td>
        </tr>       
        <tr>
            <th>2.5.2</th>
        </tr>
        <tr>
        	<td>Changes for git.</td>
        </tr>       
        <tr>
            <th>2.5.1</th>
        </tr>
        <tr>
        	<td>Subapplication caption now tries to translate 'project.name' first, then falls back to bundle name.</td>
        </tr>       
        <tr>
        	<td>Fixed confusion between buttons and checkboxes.</td>
        </tr>       
        <tr>
        	<td>Set MaxLength on text fields.</td>
        </tr>       
        <tr>
        	<td>Eliminate BeanUtils references and use MaduraObjects metadata instead. BeanUtils was giving odd results.</td>
        </tr>       
        <tr>
        	<td>More flexible handling of message source accessor, specifically when the message source may exist in a bundle
        	rather than the main application, it now gets passed around as an argument.</td>
        </tr>       
        <tr>
        	<td>Better clean up of registered fields and labels on close of session.</td>
        </tr>       
        <tr>
            <td>Changed field generations so that if no write permission we set the field to read-only. Previously it was disabled instead.</td>
        </tr>
        <tr>
            <td>Changed SubmitButtonPainter so that if you set the MaduraForm to readOnly
            then the submit button will be disabled.</td>
        </tr>
        <tr>
            <td>Updated Spring dependencies.</td>
        </tr>
        <tr>
            <th>2.5.0</th>
        </tr>       
        <tr>
            <td>Moved to maven build.</td>
        </tr>
        <tr>
            <th>2.4.1</th>
        </tr>       
        <tr>
            <td>Fixed a bad pom file. The version was incorrect.</td>
        </tr>
        <tr>
            <th>2.4</th>
        </tr>       
        <tr>
            <td>Added pom file for maven projects.</td>
        </tr>
        <tr>
            <td>Touchkit is now a compile only dependency so it is not automatically pulled from the
            repository. This is to allow more explicit handling of the Touchkit licence.</td>
        </tr>
        <tr>
            <th>2.3</th>
        </tr>       
        <tr>
            <td>Built with Java 1.7.</td>
        </tr>       
        <tr>
            <th>2.2</th>
        </tr>       
        <tr>
            <td>Changed default layout to FormLayout from VerticalComponentLayout in TouchkitMaduraForm because the latter fails to handle dynamic required fields.</td>
        </tr>       
        <tr>
            <td>Added a login mechanism for Touchkit.</td>
        </tr>       
		<tr>
			<th>2.1</th>
		</tr>		
		<tr>
			<td>Fixed problem with help screen not popping back.</td>
        </tr>       
        <tr>
            <td>Added TouchkitMaduraForm.</td>
        </tr>       
        <tr>
            <th>2.0</th>
        </tr>       
        <tr>
            <td>This is a major rework which eliminates the several factories that relied on statics and singletons to work.
            This version, with a loss of backward compatibility, improves the useability of the library
            as well as making it compatible with Vaadin's Touchkit.</td>
        </tr>       
        <tr>
            <td>Added a proper sample application showing the use of the Hibernate Container.</td>
		</tr>
		<tr>
			<th>1.9</th>
		</tr>		
		<tr>
			<td>Fixed problem with logout.</td>
		</tr>
		<tr>
			<th>1.8</th>
		</tr>		
		<tr>
			<td>Fixed problem with source never displaying from ivy</td>
		</tr>
		<tr>
			<td>Added method getMaduraPropertyWrapper() to MaduraSessionManager</td>
		</tr>
		<tr>
			<td>Fixed problem in FormatterDouble which always failed to parse a valid number</td>
		</tr>
		<tr>
			<th>1.7</th>
		</tr>
		<tr>
			<td>Clearing a field doesn't fire the rules, issue #3: fixed.</td>
		</tr>
		<tr>
			<td>Added support for pluggable applications (perspective manager).</td>
		</tr>
		<tr>
			<td>Removed use of MessageSourceAccessorFactory because it does not play well with Madura Bundles.</td>
		</tr>
		<tr>
			<td>Improved numeric parsing. Previously something like 1x000 would return 1 rather than invalid. It now
			returns invalid.</td>
		</tr>
		<tr>
			<td>Added menu item control (visibility, enabled/disabled) from rules using the same mechanism as buttons.</td>
		</tr>
		<tr>
			<td>Made some more classes Serializable.</td>
		</tr>
		<tr>
			<th>1.6</th>
		</tr>
		<tr>
			<td>Added serialisation to some classes Tomcat complains about on shutdown. There are some
			Spring classes it still complains about, though.</td>
		</tr>
		<tr>
			<td>Added default login.html in case the one in the theme is missing, also show warning. The
			access of the login.html file has been tightened up so it works on Tomcat, ie more portable.</td>
		</tr>
		<tr>
			<td>Added the generic login listener: SpringLoginListener. This uses Spring Security and handles
			unpacking the authorities and using them as permissions.</td>
		</tr>
		<tr>
			<th>1.5</th>
		</tr>
		<tr>
			<td>Fixed several issues with the formattingTable.</td>
		</tr>
		<tr>
			<td>Adjusted dependencies.</td>
		</tr>
		<tr>
			<th>1.4</th>
		</tr>
		<tr>
			<td>Handling case where we add a row and then cancel, row is removed.</td>
		</tr>
		<tr>
			<td>Fixed problem with using evict which stopped us adding new rows.</td>
		</tr>
		<tr>
			<th>1.3</th>
		</tr>
		<tr>
			<td>Boolean fields now rendered as checkbox.</td>
		</tr>
		<tr>
			<td>Submit button not disabling when required field is blanked. Fixed.</td>
		</tr>
		<tr>
			<td>Fixed NPE when login fails.</td>
		</tr>
		<tr>
			<td>Setting a required field to blank failed to disable the submit button. Fixed.</td>
		</tr>
		<tr>
			<th>1.2</th>
		</tr>
		<tr>
			<td>Simplified the binding needed in the table editor.</td>
		</tr>
		<tr>
			<th>1.1</th>
		</tr>
		<tr>
			<td>Support for @Secret fields</td>
		</tr>
		<tr>
			<td>Error handling/reporting added.</td>
		</tr>
		<tr>
			<th>1.0</th>
		</tr>
		<tr>
			<td>Initial version</td>
		</tr>
		</table>
		</a1>
	</body>
	
</doc>
